.. _Top:


.. title:: Ceylan-HOWTOs: About Erlang

------
Erlang
------


.. role:: raw-html(raw)
   :format: html

.. role:: raw-latex(raw)
   :format: latex


:raw-html:`<a name="howtos_top"></a>`

:raw-html:`<div class="banner"><p><em>Ceylan HOWTOs</em> <a href="http://howtos.esperide.org">browse latest</a> <a href="Ceylan-HOWTOs-english.pdf">get PDF</a> <a href="#howtos_top">go to top</a> <a href="#howtos_toc">go to toc</a> <a href="#howtos_bottom">go to bottom</a> <a href="Ceylan-HOWTOs-overview-english.html">go to HOWTOs</a> <a href="mailto:about(dash)ceylan-howtos(at)esperide(dot)com?subject=[Ceylan-HOWTOs]%20Remark%20about%20Erlang">email us</a></p></div>`


:raw-html:`<center><img src="howtos-title.png" id="responsive-image-ultrasmall"></img>`


:Organisation: Copyright (C) 2021-GENERATION_YEAR_TAG Olivier Boudeville
:Contact: about (dash) howtos (at) esperide (dot) com
:Creation date: Saturday, November 20, 2021
:Lastly updated: GENERATION_DATE_TAG


:raw-html:`<a name="howtos_toc"></a>`

.. _`table of contents`:


.. contents:: **Table of Contents**
  :local:
  :depth: 2


:raw-html:`</center>`



Overview
========

`Erlang <https://en.wikipedia.org/wiki/Erlang_(programming_language)>`_  is a concurrent, functional programming language available as free software; see `its official website <https://www.erlang.org/>`_ for more details.

Erlang is dynamically typed, and is executed by the `BEAM virtual machine <https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)>`_. This VM (*Virtual Machine*) operates on bytecodes and can perform Just-In-Time compilation. It powers also `other related languages <https://github.com/llaisdy/beam_languages>`_, such as Elixir and LFE.



Let's Start with some Shameless Advertisement for Erlang and the BEAM VM
========================================================================

Taken from `this presentation <https://erlangforums.com/t/erlang-101-processes-parallelization/594>`_:

.. Hint::
 *What makes Elixir StackOverflow’s #4 most-loved language?*

 *What makes Erlang and Elixir StackOverflow’s #3 and #4 best-paid languages?*

 *How did WhatsApp scale to billions of users with just dozens of Erlang engineers?*

 *What’s so special about Erlang that it powers CouchDB and RabbitMQ?*

 *Why are multi-billion-dollar corporations like Bet365 and Klarna built on Erlang?*

 *Why do PepsiCo, Cars.com, Change.org, Boston’s MBTA, and Discord all rely on Elixir?*

 *Why was Elixir chosen to power a bank?*

 *Why does Cisco ship 2 million Erlang devices each year? Why is Erlang used to control 90% of Internet traffic?*



.. _`Erlang Installation`:


Installation
============

Erlang can be installed thanks to the various options listed in `these guidelines <https://www.erlang.org/downloads>`_.

Building Erlang from the sources of its latest stable version is certainly the best approach; for more control we prefer relying on our `custom procedure <https://myriad.esperide.org/#software-prerequisites>`_.

For a development activity, we recommend also specifying the following options to our ``conf/install-erlang.sh`` script:

- ``--doc-install``, so that the reference documentation can be accessed locally (in ``~/Software/Erlang/Erlang-current-documentation/``); creating a bookmark pointing to the module index, located in ``doc/man_index.html``, would most probably be useful

- ``--generate-plt`` in order to generate a PLT file allowing the static type checking that applies to this installation (may be a bit long and processing-intensive, yet it is to be done once per built Erlang version)

Run ``./install-erlang.sh --help`` for more information.

Once installed, ensure that ``~/Software/Erlang/Erlang-current-install/bin/`` is in your PATH (ex: by enriching your ``~/.bashrc`` accordingly), so that you can run ``erl`` (the Erlang interpreter) from any location, resulting a prompt like:

.. code:: bash

 $ erl
 Erlang/OTP 24 [erts-12.1.5] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit]

 Eshell V12.1.5  (abort with ^G)
 1>

Then enter ``CTRL-C`` twice in order to come back to the (UNIX) shell.

Congratulations, you have a functional Erlang now!


To check from the command-line the version of an Erlang install:

.. code:: bash

 $ erl -eval '{ok, V} = file:read_file( filename:join([code:root_dir(), "releases", erlang:system_info(otp_release), "OTP_VERSION"]) ), io:fwrite(V), halt().' -noshell
 24.2




Ceylan's Language Use
=====================

Ceylan users shall note that most of our related developments (namely `Myriad <http://myriad.esperide.org>`_, `WOOPER <http://wooper.esperide.org>`_, `Traces <http://traces.esperide.org>`_, `LEEC <http://leec.esperide.org>`_, `Seaplus <http://seaplus.esperide.org>`_, `Mobile <http://mobile.esperide.org>`_, `US-Common <http://us-common.esperide.org>`_, `US-Web <http://us-web.esperide.org>`_ and `US-Main <http://us-main.esperide.org>`_) depart significantly from the general conventions observed by most Erlang applications:

- notably because of their reliance on parse transforms, by default they rely on our own build system based on `GNU make <Build.html#gnu-make>`_ (rather than on `rebar3 <https://www.rebar3.org/>`_)
- they tend not to rely on OTP abstractions such as ``gen_server``, as WOOPER offers OOP (*Object-Oriented Programming*) ones that we prefer



Using the Shell
===============

If it is as simple to run ``erl``, we prefer, with Ceylan settings, running ``make shell`` in order to benefit from a well-initialized VM (notably with the full code path of the current layer and the ones below).

Refer then to the `shell commands <https://www.erlang.org/doc/man/shell.html#shell-commands>`_, notably for:

- ``f/1``, used as ``f(X).`` in order to *forget* a variable ``X``, i.e. to remove the binding of this variable and be able to (re)assign it afterwards
- ``rr/{1,2,3}`` (ex: used as ``rr(Path).``) to *read records* and have them available on the shell; for example, to be able to use the records defined by xmerl:

.. code:: erlang

 1> rr(code:lib_dir(xmerl) ++ "/include/xmerl.hrl").


See also the `JCL mode <https://www.erlang.org/doc/man/shell.html#jcl-mode>`_ (for *Job Control Language*) to connect and interact with other Erlang nodes.



About Security
==============

- one should not encrypt messages directly with a key pair (ex: with RSA, only messages up to around 200 bytes long can be encrypted):  one should encrypt only a *symmetric key* (generated by a cryptographically-safe random algorithm) that is then used to encrypt one's message(s); ensure an Encrypt-Then-Authenticate scheme to prevent padding oracle attacks (and a secure-compare algorithm for the *Message Authentication Code* verification to prevent timing attacks); using `libsodium <https://doc.libsodium.org/>`_ should make mistakes using the standard crypto primitives less error-prone; see the `enacl <https://github.com/jlouis/enacl>`_ Erlang binding for that; for more information, refer to `the corresponding thread <https://erlangforums.com/t/cannot-encrypt-a-long-binary-using-public-key-encrypt-private-2/724>`_

- relevant sources of information:

  - books:

	- ``Cryptography Engineering: Design Principles and Practical Applications``
	- ``Practical Cryptography``

  - the `Security Working Group <https://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/>`_ of the EEF (*Erlang Ecosystem Foundation*)



More Advanced Topics
====================


Metaprogramming
---------------

`Metaprogramming <https://en.wikipedia.org/wiki/Metaprogramming>`_ is to be done in Erlang through **parse transforms**, which are user-defined modules that transform an AST (for *Abstract Syntax Trees*, an Erlang term that represents actual code; see the `Abstract Format <https://www.erlang.org/doc/apps/erts/absform.html>`_ for more details) into another AST that is fed afterwards to the compiler.

See also:

- this `introduction to parse transforms <https://chlorophil.blogspot.com/2007/04/erlang-macro-processor-v1-part-i.html>`_
- Ceylan-Myriad's `support for metaprogramming <https://myriad.esperide.org/#support-for-metaprogramming>`_




Improper Lists
--------------

A proper list is created from the empty one (``[]``, also known as "nil") by appending (with the ``|`` operator, a.k.a. "cons") elements in turn; for example ``[1,2]`` is actually ``[1 | [2 | []]]``.

However, instead of enriching a list from the empty one, one *can* start a list with any other term than ``[]``, for example ``my_atom``. Then, instead of ``[2|[]]``, ``[2|my_atom]`` may be specified and will be indeed a list - albeit an improper one.

Many recursive functions expect proper lists, and will fail (typically with a function clause) if given an improper list to process (ex: ``lists:flatten/1``).

So, why not banning such construct? Why even standard modules like ``digraph`` rely on improper lists?

.. inexact: The reason is that improper lists are a way to reduce the memory footprint of some datastructures, by storing a value of interest (provided that it fits here as an immediate value, i.e. roughly that this value is no larger than a pointer) instead of the empty list.

The reason is that improper lists are a way to reduce the memory footprint of some datastructures, by storing a value of interest instead of the empty list.


Indeed, as explained `in this post <https://groups.google.com/g/erlang-programming/c/mQLS5yGX_8g/m/Ad4VVyOUDQAJ>`_, a (proper) list of 2 elements will consume:

- 1 list cell (2 words of memory) to store the first element and a pointer to second cell
- 1 list cell (2 more words) to store the second element and the empty list

For a total of 4 words of memory (so, on a 64-bit architecture, it is 32 bytes).

As for an improper list of 2 elements, only 1 list cell (2 words of memory) will be consumed to store the first element and then the second one.

Such a solution is even more compact than a pair (a 2-element tuple), which consumes 2+1 = 3 words. Accessing the elements of an improper list is also faster (one handle to be inspected vs also an header to be inspected).

Finally, for sizes expressed in bytes:

.. code:: erlang

 1> system_utils:get_size([2,my_atom]).
 40

 2> system_utils:get_size({2,my_atom}).
 32

 3> system_utils:get_size([2|my_atom]).
 24


See also the `1 <http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html#lists-cons>`_, `2 <http://beam-wisdoms.clau.se/en/latest/indepth-data-sizes.html#list>`_ pointers for more information.

Everyone shall decide on whether relying on improper lists is a trick, a hack or a technique to prohibit.



Post-Mortem Investigations
--------------------------

Erlang programs may fail, and this may result in mere (Erlang-level) crashes (the VM detects an error, and reports information about it, possibly in the form of a crash dump) or (sometimes, quite infrequently though) in more brutal, lower-level core dumps (the VM crashes as a whole, like any faulty program run by the operating system); this last case happens typically when relying on faulty `NIFs <https://www.erlang.org/doc/tutorial/nif.html>`_.


Erlang Crash Dumps
..................

If experiencing "only" an Erlang-level crash, a ``erl_crash.dump`` file is produced in the directory whence the executable (generally ``erl``) was launched. The best way to study it is to use the ``cdv`` (refer to `crashdump viewer <https://www.erlang.org/doc/apps/observer/crashdump_ug.html>`_) tool, available, from the Erlang installation, as ``lib/erlang/cdv`` [#]_.

.. [#] Hence, according to the Ceylan-Myriad conventions, in ``~/Software/Erlang/Erlang-current-install/lib/erlang/cdv``.

Using this debug tool is as easy as:

.. code:: bash

 $ cdv erl_crash.dump

Then, through the wx-based interface, a rather large number of Erlang-level information will be available (processes, ports, ETS tables, nodes, modules, memory, etc.) to better understand the context of this crash and hopefully diagnose its root cause.


Core Dumps
..........

In the worst cases, the VM will crash like any other OS-level process, and generic (non Erlang-specific) tools will have to be used. Do not expect to be pointed to line numbers in Erlang source files anymore!

Refer to our general section dedicated to `core dumps <GNULinux.html#core-dumps>`_ for that.



Language Bindings
=================

The two main approaches in order to integrate third-party code to Erlang are to:

- interact with it as if it was another Erlang node; we defined `Ceylan-Seaplus <http://seaplus.esperide.org>`_ for that purpose
- directly link the current Erlang VM to this code, through `NIF <https://www.erlang.org/doc/tutorial/nif.html>`_; it can be done manually, or may be automatised thanks to `nifty <https://github.com/parapluu/nifty>`_; this can be especially useful for larger APIs (ex: `SDL <https://www.libsdl.org/>`_)



Language Implementation
=======================


Message-Passing: Copying vs Sharing
-----------------------------------

Knowing that, in functional languages such as Erlang, terms ("variables") are immutable, why could not they be shared between local processes when sent through messages, instead of being copied in the heap of each of them, as it is actually the case with the Erlang VM?

The reason lies in the fact that, beyond the constness of these terms, their life-cycle has also to be managed. If they are copied, each process can very easily perform its (concurrent, autonomous) garbage collections. On the contrary, if terms were shared, then reference counting would be needed to deallocate them properly (neither too soon nor never at all), which, in a concurrent context, is bound to require locks.

So a trade-off between memory (due to data duplication) and processing (due to lock contention) has to be found and at least for most terms (excepted larger binaries), the sweet spot consists in sacrificing a bit of memory in favour of a lesser CPU load. Solutions like `persistent_term <https://www.erlang.org/doc/man/persistent_term.html>`_ may address situations where more specific needs arise.


.. _JIT:

Just-in-Time Compilation
------------------------

This long-awaited feature, named *BeamAsm* and whose rationale and history have been detailed in `these articles <https://www.erlang.org/blog/the-road-to-the-jit/>`_, has been introduced in Erlang 24 and shall transparently lead to increased performances for most applications.




Static Typing
-------------

Static type checking can be performed on Erlang code; the usual course of action is to use `Dialyzer <https://www.erlang.org/doc/man/dialyzer.html>`_ - albeit other solutions like `Gradualizer <https://github.com/josefs/Gradualizer>`_ exist.

A few `statically-typed languages <https://github.com/llaisdy/beam_languages#statically-typed-languages>`_ can operate on top of the Erlang VM, even if none has reached yet the popularity of Erlang or Elixir (that are dynamically-typed).

In addition to the increased type safety that statically-typed languages permit (possibly applying to sequential code but also to inter-process messages), it is unsure whether such extra static awareness may also lead to better performances (especially now that the standard compiler supports JIT_).



Intermediate Languages
----------------------

To better discover the inner workings of the Erlang compilation, one may look at the `eplaypen online demo <http://tryerl.seriyps.ru/>`_ (whose project is `here <https://github.com/seriyps/eplaypen>`_) and/or at the `Compiler Explorer <https://godbolt.org/>`_ (which supports the Erlang language among others).

Both of them allow to read the intermediate representations involved when compiling Erlang code (BEAM stage, erl_scan, preprocessed sources, abstract code, Core Erlang, Static Single Assignment form, BEAM VM assembler opcodes, x86-64 assembler generated by the JIT, etc.).



Micro-Cheat Sheet
=================

To avoid having to perform a lookup in the documentation:

- Erlang indices start at ``1``, except the ones of the ``array`` module that are zero-based
- for tuples of unknown number of elements:

  - **setting** an element is to be done with ``setelement(positive_index(), tuple(), term()) -> tuple()``
  - **extracting** an element is to be done with ``element(positive_index(), tuple()) -> term()``
  - **adding** an element at a given index (ex: to append a record tag) is to be done with ``erlang:insert_element(positive_index(), tuple(), term()) -> tuple()``

  - **removing** an element at a given index (ex: to chop a record tag) is to be done with ``erlang:delete_element(positive_index(), tuple()) -> tuple()``

(no need for the ``erlang`` module to be explicitly specified for the first two functions, as both are auto-imported)

- the two tables (test/others) of the `BIFs supported in guards expressions <https://www.erlang.org/doc/reference_manual/expressions.html#guard-expressions>`_

- `operator precedence <https://www.erlang.org/doc/reference_manual/expressions.html#operator-precedence>`_



Erlang Resources
================

- the reference is the `Erlang official website <http://erlang.org>`_

- for teaching purpose, we would dearly recommend `Learn You Some Erlang for Great Good! <https://learnyousomeerlang.com/content>`_; many other high-quality `Erlang books <https://erlangforums.com/c/erlang-learning-resources/8>`_ exist as well; one may also check the `Erlang track <https://exercism.org/tracks/erlang>`_ on Exercism

- in addition to the module index mentioned in the `Erlang Installation`_ section, using the `online search <https://erlang.org/doc/search/>`_ and/or `Erldocs <https://erldocs.com/>`_ may also be convenient

- the Erlang `community <https://www.erlang.org/community>`_ is known to be pleasant and welcoming to newcomers; one may visit the `Erlang forums <https://erlangforums.com/>`_, which complement the `erlang-questions <https://erlang.org/pipermail/erlang-questions/>`_ mailing list (use `this mirror <https://groups.google.com/g/erlang-programming>`_ in order to search through the past messages of this list)

- for those who are interested in parse transforms (the Erlang way of doing metaprogramming), the `section about The Abstract Format <https://www.erlang.org/doc/apps/erts/absform.html>`_ is essential (despite not being well known)

- to better understand the inner workings of the VM: `The Erlang Runtime System <https://blog.stenmans.org/theBeamBook/>`_, a.k.a. "the BEAM book", by Erik Stenman

- `BEAM Wisdoms <http://beam-wisdoms.clau.se/en/latest>`_, by Dmytro Lytovchenko

