.. _Top:


.. title:: Ceylan-HOWTOs: About Erlang

------
Erlang
------


.. role:: raw-html(raw)
   :format: html

.. role:: raw-latex(raw)
   :format: latex


:raw-html:`<a name="howtos_top"></a>`

:raw-html:`<div class="banner"><p><em>Ceylan HOWTOs</em> <a href="http://howtos.esperide.org">browse latest</a> <a href="Ceylan-HOWTOs-english.pdf">get PDF</a> <a href="#howtos_top">go to top</a> <a href="#howtos_toc">go to toc</a> <a href="#howtos_bottom">go to bottom</a> <a href="Ceylan-HOWTOs-overview-english.html">go to HOWTOs</a> <a href="mailto:about(dash)ceylan-howtos(at)esperide(dot)com?subject=[Ceylan-HOWTOs]%20Remark%20about%20Erlang">email us</a></p></div>`


:raw-html:`<center><img src="howtos-title.png" id="responsive-image-ultrasmall"></img>`


:Organisation: Copyright (C) 2021-GENERATION_YEAR_TAG Olivier Boudeville
:Contact: about (dash) howtos (at) esperide (dot) com
:Creation date: Saturday, November 20, 2021
:Lastly updated: GENERATION_DATE_TAG


:raw-html:`<a name="howtos_toc"></a>`

.. _`table of contents`:


.. contents:: **Table of Contents**
  :local:
  :depth: 2


:raw-html:`</center>`



Overview
========

`Erlang <https://en.wikipedia.org/wiki/Erlang_(programming_language)>`_  is a concurrent, functional programming language available as free software; see `its official website <https://www.erlang.org/>`_ for more details.

Erlang is dynamically typed, and is executed by the `BEAM virtual machine <https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)>`_. This VM (*Virtual Machine*) operates on bytecodes and can perform Just-In-Time compilation. It powers also `other related languages <https://github.com/llaisdy/beam_languages>`_, such as Elixir and LFE.



Let's Start with some Shameless Advertisement for Erlang and the BEAM VM
========================================================================

Taken from `this presentation <https://erlangforums.com/t/erlang-101-processes-parallelization/594>`_:

.. Hint::
 What makes Elixir StackOverflow’s #4 most-loved language?

 What makes Erlang and Elixir StackOverflow’s #3 and #4 best-paid languages?

 How did WhatsApp scale to billions of users with just dozens of Erlang engineers?

 What’s so special about Erlang that it powers CouchDB and RabbitMQ?

 Why are multi-billion-dollar corporations like Bet365 and Klarna built on Erlang?

 Why do PepsiCo, Cars.com, Change.org, Boston’s MBTA, and Discord all rely on Elixir?

 Why was Elixir chosen to power a bank?

 Why does Cisco ship 2 million Erlang devices each year? Why is Erlang used to control 90% of Internet traffic?



.. _`Erlang Installation`:


Installation
============

Erlang can be installed thanks to the various options listed in `these guidelines <https://www.erlang.org/downloads>`_.

Building Erlang from the sources of its latest stable version is certainly the best approach; for more control we prefer relying on our `custom procedure <https://myriad.esperide.org/#software-prerequisites>`_.

For a development activity, we recommend also specifying the following options to our ``conf/install-erlang.sh`` script:

- ``--doc-install``, so that the reference documentation can be accessed locally (in ``~/Software/Erlang/Erlang-current-documentation/``); creating a bookmark pointing to the module index, located in ``doc/man_index.html``, would most probably be useful

- ``--generate-plt`` in order to generate a PLT file allowing the static type checking that applies to this installation (may be a bit long and processing-intensive, yet it is to be done once per built Erlang version)

Run ``./install-erlang.sh --help`` for more information.

Once installed, ensure that ``~/Software/Erlang/Erlang-current-install/bin/`` is in your PATH (ex: by enriching your ``~/.bashrc`` accordingly), so that you can run ``erl`` (the Erlang interpreter) from any location, resulting a prompt like:

.. code:: bash

 $ erl
 Erlang/OTP 24 [erts-12.1.5] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit]

 Eshell V12.1.5  (abort with ^G)
 1>

Then enter ``CTRL-C`` twice in order to come back to the (UNIX) shell.

Congratulations, you have a functional Erlang now!



Ceylan's Language Use
=====================

Ceylan users shall note that most of our related developments (namely `Myriad <http://myriad.esperide.org>`_, `WOOPER <http://wooper.esperide.org>`_, `Traces <http://traces.esperide.org>`_, `LEEC <http://leec.esperide.org>`_, `Seaplus <http://seaplus.esperide.org>`_, `Mobile <http://mobile.esperide.org>`_, `US-Common <http://us-common.esperide.org>`_, `US-Web <http://us-web.esperide.org>`_ and `US-Main <http://us-main.esperide.org>`_) depart significantly from the general conventions observed by most Erlang applications:

- notably because of their reliance on parse transforms, by default they rely on our own build system based on `GNU make <Build.html#gnu-make>`_ (rather than on `rebar3 <https://www.rebar3.org/>`_)
- they tend not to rely on OTP abstractions such as ``gen_server``, as WOOPER offers OOP (*Object-Oriented Programming*) ones that we prefer



Using the Shell
===============

If it is as simple to run ``erl``, we prefer, with Ceylan settings, running ``make shell`` in order to benefit from a well-initialized VM (notably with the full code path of the current layer and the ones below).

Refer then to the `shell commands <https://www.erlang.org/doc/man/shell.html#shell-commands>`_, notably for:

- ``f/1``, used as ``f(X).`` in order to *forget* a variable ``X``, i.e. to remove the binding of this variable and be able to (re)assign it afterwards
- ``rr/{1,2,3}`` (ex: used as ``rr(Path).``) to *read records* and have them available on the shell; for example, to be able to use the records defined by xmerl:

.. code:: erlang

 1> rr(code:lib_dir(xmerl) ++ "/include/xmerl.hrl").


See also the `JCL mode <https://www.erlang.org/doc/man/shell.html#jcl-mode>`_ (for *Job Control Language*) to connect and interact with other Erlang nodes.



About Security
==============

- one should not encrypt messages directly with a key pair (ex: with RSA, only messages up to around 200 bytes long can be encrypted):  one should encrypt only a *symmetric key* (generated by a cryptographically-safe random algorithm) that is then used to encrypt one's message(s); ensure an Encrypt-Then-Authenticate scheme to prevent padding oracle attacks (and a secure-compare algorithm for the *Message Authentication Code* verification to prevent timing attacks); using `libsodium <https://doc.libsodium.org/>`_ should make mistakes using the standard crypto primitives less error-prone; see the `enacl <https://github.com/jlouis/enacl>`_ Erlang binding for that; for more information, refer to `the corresponding thread <https://erlangforums.com/t/cannot-encrypt-a-long-binary-using-public-key-encrypt-private-2/724>`_

- relevant sources of information:

  - books:

	- ``Cryptography Engineering: Design Principles and Practical Applications``
	- ``Practical Cryptography``

  - the `Security Working Group <https://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/>`_ of the EEF (*Erlang Ecosystem Foundation*)



More Advanced Topics
====================


Metaprogramming
---------------

`Metaprogramming <https://en.wikipedia.org/wiki/Metaprogramming>`_ is to be done in Erlang through **parse transforms**, which are user-defined modules that transform an AST (for *Abstract Syntax Trees*, an Erlang term that represents actual code; see the `Abstract Format <https://www.erlang.org/doc/apps/erts/absform.html>`_ for more details) into another AST that is fed afterwards to the compiler.

See also:

- this `introduction to parse transforms <https://chlorophil.blogspot.com/2007/04/erlang-macro-processor-v1-part-i.html>`_
- Ceylan-Myriad's `support for metaprogramming <https://myriad.esperide.org/#support-for-metaprogramming>`_




Improper Lists
--------------

A proper list is created from the empty one (``[]``, also known as "nil") by appending (with the ``|`` operator, a.k.a. "cons") elements in turn; for example ``[1,2]`` is actually ``[1 | [2 | []]]``.

However, instead of enriching a list from the empty one, one *can* start a list with any other term than ``[]``, for example ``my_atom``. Then, instead of ``[2|[]]``, ``[2|my_atom]`` may be specified and will be indeed a list - albeit an improper one.

Many recursive functions expect proper lists, and will fail (typically with a function clause) if given an improper list to process (ex: ``lists:flatten/1``).

So, why not banning such construct? Why even standard modules like ``digraph`` rely on improper lists?

.. inexact: The reason is that improper lists are a way to reduce the memory footprint of some datastructures, by storing a value of interest (provided that it fits here as an immediate value, i.e. roughly that this value is no larger than a pointer) instead of the empty list.

The reason is that improper lists are a way to reduce the memory footprint of some datastructures, by storing a value of interest instead of the empty list.


Indeed, as explained `in this post <https://groups.google.com/g/erlang-programming/c/mQLS5yGX_8g/m/Ad4VVyOUDQAJ>`_, a (proper) list of 2 elements will consume:

- 1 list cell (2 words of memory) to store the first element and a pointer to second cell
- 1 list cell (2 more words) to store the second element and the empty list

For a total of 4 words of memory (so, on a 64-bit architecture, it is 32 bytes).

As for an improper list of 2 elements, only 1 list cell (2 words of memory) will be consumed to store the first element and then the second one.

Such a solution is even more compact than a pair (a 2-element tuple), which consumes 2+1 = 3 words. Accessing the elements of an improper list is also faster (one handle to be inspected vs also an header to be inspected).

Finally, for sizes expressed in bytes:

.. code:: erlang

 1> system_utils:get_size([2,my_atom]).
 40

 2> system_utils:get_size({2,my_atom}).
 32

 3> system_utils:get_size([2|my_atom]).
 24


See also the `1 <http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html#lists-cons>`_, `2 <http://beam-wisdoms.clau.se/en/latest/indepth-data-sizes.html#list>`_ pointers for more information.

Everyone shall decide on whether relying on improper lists is a trick, a hack or a technique to prohibit.



Post-Mortem Investigations
--------------------------

Erlang programs may fail, and this may result in mere (Erlang-level) crashes (the VM detects an error, and reports information about it) or in more brutal, lower-level core dumps (the VM crashes as a whole, like any faulty program run by the operating system).


Erlang Crash Dumps
..................

If experiencing "only" an Erlang-level crash, a ``erl_crash.dump`` file is produced in the directory whence the executable (generally ``erl``) was launched. The best way to study it is to use the ``cdv`` (refer to `crashdump viewer <https://www.erlang.org/doc/apps/observer/crashdump_ug.html>`_) tool, available, from the Erlang installation, as ``lib/erlang/cdv`` [#]_.

.. [#] Hence, according to the Ceylan-Myriad conventions, in ``~/Software/Erlang/Erlang-current-install/lib/erlang/cdv``.

Using this debug tool is as easy as::

 $ cdv erl_crash.dump

Then, through the wx-based interface, a rather large number of Erlang-level information will be available (processes, ports, ETS tables, nodes, modules, memory, etc.) to better understand the context of this crash and hopefully diagnose its root cause.


Core Dumps
..........

In the worst cases, the VM will crash like any other OS-level process, and generic (non Erlang-specific) tools will have to be used. Do not expect to be pointed to line numbers in Erlang source files anymore!

This `Arch Linux article <https://wiki.archlinux.org/title/Core_dump>`_ will give all relevant details.

In short, ``coredumpctl list`` will list all known core dumps from oldest to most recent, such as in::

 $ coredumpctl list
 TIME                        PID   UID  GID SIG     COREFILE EXE                SIZE
 [...]
 Tue 2021-12-21 20:53:02 CET 73873 1007 988 SIGSEGV present  [...]/bin/beam.smp 14.6M


The last core dump produced may be studied directly, thanks to ``coredumpctl debug``, relying on ``gdb`` to fetch much lower-level information::

 $ coredumpctl debug
		   PID: 73873 (beam.smp)
		   UID: 1007 (xxx)
		   GID: 988 (users)
		Signal: 11 (SEGV)
	 Timestamp: Tue 2021-12-21 20:53:01 CET (38min ago)
  Command Line: /home/xxx/Software/Erlang/Erlang-24.2/lib/erlang/erts-12.2/bin/beam.smp -W w -K true -A 128 [...]
	Executable: /home/xxx/Software/Erlang/Erlang-24.2/lib/erlang/erts-12.2/bin/beam.smp
 Control Group: /user.slice/user-1007.slice/session-2.scope
		  Unit: session-2.scope
		 Slice: user-1007.slice
	   Session: 2
	 Owner UID: 1007 (xxx)
	   Boot ID: f8abe9473f7e4fea8ba24944e35ce7d9
	Machine ID: c9413a71e7b4498f831e2df7a08e5f33
	  Hostname: xxx
	   Storage: /var/lib/systemd/coredump/core.beam\x2esmp.1007.f8abe9473f7e4fea8ba24944e35ce7d9.73873.1640116381000000.zst (present)
	 Disk Size: 14.6M
	   Message: Process 73873 (beam.smp) of user 1007 dumped core.

				Found module /home/xxx/Software/Erlang/Erlang-24.2/lib/erlang/erts-12.2/bin/beam.smp with build-id: 8cfbf76728dd7399444638f1ba124471181840e7
				Found module /home/xxx/Software/Erlang/Erlang-24.2/lib/erlang/lib/wx-2.1.1/priv/erl_gl.so with build-id: 0b96532e586839d3da9afd6e5f23aa76346a0e45
 [...]
	Stack trace of thread 74039:
	#0  0x00007f6e5461a74b __memmove_avx_unaligned_erms (libc.so.6 + 0x16374b)
	#1  0x00007f6d8a204428 n/a (iris_dri.so + 0xd12428)
	#2  0x00007f6d89733207 n/a (iris_dri.so + 0x241207)
	#3  0x00007f6d89733c97 n/a (iris_dri.so + 0x241c97)
	#4  0x00007f6d898d8b0d n/a (iris_dri.so + 0x3e6b0d)
	#5  0x00007f6d898d8bf2 n/a (iris_dri.so + 0x3e6bf2)
	#6  0x00007f6d8b2f241c n/a (/home/xxx/Software/Erlang/Erlang-24.2/lib/erlang/lib/wx-2.1.1/priv/erl_gl.so + 0x5b41c)
 [New LWP 74039]
 [New LWP 73873]
 [...]
 Core was generated by `/home/xxx/Software/Erlang/Erlang-24.2/lib/erlang/erts-12.2/bin/beam.smp -'.
 Program terminated with signal SIGSEGV, Segmentation fault.
 #0  0x00007f6e5461a74b in __memmove_avx_unaligned_erms () from /usr/lib/libc.so.6
 [Current thread is 1 (Thread 0x7f6d900aa640 (LWP 74039))]


Then::

 (gdb) bt
 [...]
 #0  0x00007f6e5461a74b in __memmove_avx_unaligned_erms () at /usr/lib/libc.so.6
 #1  0x00007f6d8a204428 in  () at /usr/lib/dri/iris_dri.so
 #2  0x00007f6d89733207 in  () at /usr/lib/dri/iris_dri.so
 #3  0x00007f6d89733c97 in  () at /usr/lib/dri/iris_dri.so
 #4  0x00007f6d898d8b0d in  () at /usr/lib/dri/iris_dri.so
 #5  0x00007f6d898d8bf2 in  () at /usr/lib/dri/iris_dri.so
 #6  0x00007f6d8b2f241c in ecb_glTexImage2D(ErlNifEnv*, ErlNifPid*, ERL_NIF_TERM*) (env=0x5642f62bdea0, self=0x5642f665e148, argv=0x5642f665e168) at gen/gl_nif.cpp:2844
 [...]
 #29 0x00007f6d92967188 in wxe_main_loop(void*) (_unused=<optimized out>) at wxe_main.cpp:138

(this example was a wx/OpenGL-oriented crash)

From there, `standard gdb-fu <https://sourceware.org/gdb/current/onlinedocs/gdb/>`_ shall be sufficient to give much insight. Once done, use ``q`` to quit.




Language Bindings
=================

The two main approaches in order to integrate third-party code to Erlang are to:

- interact with it as if it was another Erlang node; we defined `Ceylan-Seaplus <http://seaplus.esperide.org>`_ for that purpose
- directly link the current Erlang VM to this code, through `NIF <https://www.erlang.org/doc/tutorial/nif.html>`_; it can be done manually, or may be automatised thanks to `nifty <https://github.com/parapluu/nifty>`_; this can be especially useful for larger APIs (ex: `SDL <https://www.libsdl.org/>`_)



Language Implementation
=======================


Message-Passing: Copying vs Sharing
-----------------------------------

Knowing that, in functional languages such as Erlang, terms ("variables") are immutable, why could not they be shared between local processes when sent through messages, instead of being copied in the heap of each of them, as it is actually the case with the Erlang VM?

The reason lies in the fact that, beyond the constness of these terms, their life-cycle has also to be managed. If they are copied, each process can very easily perform its (concurrent, autonomous) garbage collections. On the contrary, if terms were shared, then reference counting would be needed to deallocate them properly (neither too soon nor never at all), which, in a concurrent context, is bound to require locks.

So a trade-off between memory (due to data duplication) and processing (due to lock contention) has to be found and at least for most terms (excepted larger binaries), the sweet spot consists in sacrificing a bit of memory in favour of a lesser CPU load. Solutions like `persistent_term <https://www.erlang.org/doc/man/persistent_term.html>`_ may address situations where more specific needs arise.


.. _JIT:

Just-in-Time Compilation
------------------------

This long-awaited feature, named *BeamAsm* and whose rationale and history have been detailed in `these articles <https://www.erlang.org/blog/the-road-to-the-jit/>`_, has been introduced in Erlang 24 and shall transparently lead to increased performances for most applications.




Static Typing
-------------

Static type checking can be performed on Erlang code; the usual course of action is to use `Dialyzer <https://www.erlang.org/doc/man/dialyzer.html>`_ - albeit other solutions like `Gradualizer <https://github.com/josefs/Gradualizer>`_ exist.

A few `statically-typed languages <https://github.com/llaisdy/beam_languages#statically-typed-languages>`_ can operate on top of the Erlang VM, even if none has reached yet the popularity of Erlang or Elixir (that are dynamically-typed).

In addition to the increased type safety that statically-typed languages permit (possibly applying to sequential code but also to inter-process messages), it is unsure whether such extra static awareness may also lead to better performances (especially now that the standard compiler supports JIT_).



Intermediate Languages
----------------------

To better discover the inner workings of the Erlang compilation, one may look at the `eplaypen online demo <http://tryerl.seriyps.ru/>`_ (whose project is `here <https://github.com/seriyps/eplaypen>`_) and/or at the `Compiler Explorer <https://godbolt.org/>`_ (which supports the Erlang language among others).

Both of them allow to read the intermediate representations involved when compiling Erlang code (BEAM stage, erl_scan, preprocessed sources, abstract code, Core Erlang, Static Single Assignment form, BEAM VM assembler opcodes, x86-64 assembler generated by the JIT, etc.).



Erlang Resources
================

- the reference is the `Erlang official website <http://erlang.org>`_

- for teaching purpose, we would dearly recommend `Learn You Some Erlang for Great Good! <https://learnyousomeerlang.com/content>`_; many other high-quality `Erlang books <https://erlangforums.com/c/erlang-learning-resources/8>`_ exist as well; one may also check the `Erlang track <https://exercism.org/tracks/erlang>`_ on Exercism

- in addition to the module index mentioned in the `Erlang Installation`_ section, using the `online search <https://erlang.org/doc/search/>`_ and/or `Erldocs <https://erldocs.com/>`_ may also be convenient

- the Erlang `community <https://www.erlang.org/community>`_ is known to be pleasant and welcoming to newcomers; one may visit the `Erlang forums <https://erlangforums.com/>`_, which complement the `erlang-questions <https://erlang.org/pipermail/erlang-questions/>`_ mailing list

- for those who are interested in parse transforms (the Erlang way of doing metaprogramming), the `section about The Abstract Format <https://www.erlang.org/doc/apps/erts/absform.html>`_ is esential (despite not being well known)

- to better understand the inner working of the VM: `The Erlang Runtime System <https://blog.stenmans.org/theBeamBook/>`_, a.k.a. "the BEAM book", by Erik Stenman

- `BEAM Wisdoms <http://beam-wisdoms.clau.se/en/latest>`_, by Dmytro Lytovchenko

