.. _Top:


.. title:: Ceylan-HOWTOs: About Erlang

------
Erlang
------


.. role:: raw-html(raw)
   :format: html

.. role:: raw-latex(raw)
   :format: latex


:raw-html:`<a name="howtos_top"></a>`

:raw-html:`<div class="banner"><p><em>Ceylan HOWTOs</em> <a href="http://howtos.esperide.org">browse latest</a> <a href="Ceylan-HOWTOs-english.pdf">get PDF</a> <a href="#howtos_top">go to top</a> <a href="#howtos_toc">go to toc</a> <a href="#howtos_bottom">go to bottom</a> <a href="Ceylan-HOWTOs-overview-english.html">go to HOWTOs</a> <a href="mailto:about(dash)ceylan-howtos(at)esperide(dot)com?subject=[Ceylan-HOWTOs]%20Remark%20about%20Erlang">email us</a></p></div>`


:raw-html:`<center><img src="howtos-title.png" id="responsive-image-ultrasmall"></img>`


:Organisation: Copyright (C) 2021-GENERATION_YEAR_TAG Olivier Boudeville
:Contact: about (dash) howtos (at) esperide (dot) com
:Creation date: Saturday, November 20, 2021
:Lastly updated: GENERATION_DATE_TAG


:raw-html:`<a name="howtos_toc"></a>`

.. _`table of contents`:


.. contents:: **Table of Contents**
  :local:
  :depth: 2


:raw-html:`</center>`



Overview
========

`Erlang <https://en.wikipedia.org/wiki/Erlang_(programming_language)>`_  is a concurrent, functional programming language available as free software; see `its official website <https://www.erlang.org/>`_ for more details.

Erlang is dynamically typed, and is executed by the `BEAM virtual machine <https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)>`_. This VM (*Virtual Machine*) operates on bytecodes and can perform Just-In-Time compilation. It powers also `other related languages <https://github.com/llaisdy/beam_languages>`_, such as Elixir and LFE.



Let's Start with some Shameless Advertisement for Erlang and the BEAM VM
========================================================================

Taken from `this presentation <https://erlangforums.com/t/erlang-101-processes-parallelization/594>`_:

.. Hint::
 *What makes Elixir StackOverflow’s #4 most-loved language?*

 *What makes Erlang and Elixir StackOverflow’s #3 and #4 best-paid languages?*

 *How did WhatsApp scale to billions of users with just dozens of Erlang engineers?*

 *What’s so special about Erlang that it powers CouchDB and RabbitMQ?*

 *Why are multi-billion-dollar corporations like Bet365 and Klarna built on Erlang?*

 *Why do PepsiCo, Cars.com, Change.org, Boston’s MBTA, and Discord all rely on Elixir?*

 *Why was Elixir chosen to power a bank?*

 *Why does Cisco ship 2 million Erlang devices each year? Why is Erlang used to control 90% of Internet traffic?*



.. _`Erlang Installation`:


Installation
============

Erlang can be installed thanks to the various options listed in `these guidelines <https://www.erlang.org/downloads>`_.

Building Erlang from the sources of its latest stable version is certainly the best approach; for more control we prefer relying on our `custom procedure <https://myriad.esperide.org/#software-prerequisites>`_.

For a development activity, we recommend also specifying the following options to our ``conf/install-erlang.sh`` script:

- ``--doc-install``, so that the reference documentation can be accessed locally (in ``~/Software/Erlang/Erlang-current-documentation/``); creating a bookmark pointing to the module index, located in ``doc/man_index.html``, would most probably be useful

- ``--generate-plt`` in order to generate a PLT file allowing the static type checking that applies to this installation (may be a bit long and processing-intensive, yet it is to be done once per built Erlang version)

Run ``./install-erlang.sh --help`` for more information.

Once installed, ensure that ``~/Software/Erlang/Erlang-current-install/bin/`` is in your PATH (e.g. by enriching your ``~/.bashrc`` accordingly), so that you can run ``erl`` (the Erlang interpreter) from any location, resulting a prompt like:

.. code:: bash

 $ erl
 Erlang/OTP 24 [erts-12.1.5] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit]

 Eshell V12.1.5  (abort with ^G)
 1>

Then enter ``CTRL-C`` twice in order to come back to the (UNIX) shell.

Congratulations, you have a functional Erlang now!


To check from the command-line the version of an Erlang install:

.. code:: bash

 $ erl -eval '{ok, V} = file:read_file( filename:join([code:root_dir(), "releases", erlang:system_info(otp_release), "OTP_VERSION"]) ), io:fwrite(V), halt().' -noshell
 24.2




Ceylan's Language Use
=====================

Ceylan users shall note that most of our related developments (namely `Myriad <http://myriad.esperide.org>`_, `WOOPER <http://wooper.esperide.org>`_, `Traces <http://traces.esperide.org>`_, `LEEC <http://leec.esperide.org>`_, `Seaplus <http://seaplus.esperide.org>`_, `Mobile <http://mobile.esperide.org>`_, `US-Common <http://us-common.esperide.org>`_, `US-Web <http://us-web.esperide.org>`_ and `US-Main <http://us-main.esperide.org>`_) depart significantly from the general conventions observed by most Erlang applications:

- notably because of their reliance on parse transforms, by default they rely on our own build system based on `GNU make <Build.html#gnu-make>`_ (rather than on `rebar3 <https://www.rebar3.org/>`_)
- they tend not to rely on OTP abstractions such as ``gen_server``, as WOOPER offers OOP (*Object-Oriented Programming*) ones that we prefer



Using the Shell
===============

If it is as simple to run ``erl``, we prefer, with Ceylan settings, running ``make shell`` in order to benefit from a well-initialized VM (notably with the full code path of the current layer and the ones below).

Refer then to the `shell commands <https://www.erlang.org/doc/man/shell.html#shell-commands>`_, notably for:

- ``f/1``, used as ``f(X).`` in order to *forget* a variable ``X``, i.e. to remove the binding of this variable and be able to (re)assign it afterwards
- ``l/1`` (apparently undocumented), used as ``l(my_module)``, to (re)load that module, purging any old version of it; convenient to reload also specifically-built BEAMs (e.g. based on parse transforms) that may have been compiled behind the scene
- ``v/1``: ``v(N)`` returns, if:

  - ``N > 0``: the result value of command of (absolute) number ``N``
  - ``N < 0``: the result value of any previous N-th command; for example ``v(-1)`` corresponds to the value of any previous command

- ``rl/1`` is *not* "reload (module)" (use ``l/1`` for that), it is "record list" (it prints selected record definitions)
- ``c/1``, used as ``c(my_module)``, to compile (if necessary) *and* (re)load that module, purging any old version of it
- ``rr/{1,2,3}`` (e.g. used as ``rr(Path).``) to *read records* and have them available on the shell; for example, to be able to use the records defined by xmerl:

.. code:: erlang

 1> rr(code:lib_dir(xmerl) ++ "/include/xmerl.hrl").


See also the `JCL mode <https://www.erlang.org/doc/man/shell.html#jcl-mode>`_ (for *Job Control Language*) to connect and interact with other Erlang nodes.



Distributed Mode of Operation
=============================


General Information
-------------------

The goal is to have processes, running on multiple Erlang VMs instantiated on various hosts of a network, interact (of course, as always, by message-passing based on Erlang processes).


Testing
.......

Let's suppose that we have two hosts, ``foo.example.com`` (possibly on the LAN) and ``bar.other.info`` (for example a gateway available on the Internet - hence a bit secured, and with many settings activated), each having the latest version of Erlang installed.


To test whether VMs on either side can communicate, one may launch on ``foo.example.com``  for example (killing EMPD and using a specific, rather random port for it, for safer/paranoid testing; specifying here a TCP port range to remind that it matters, firewall-wise)::

 $ killall epmd

 # Possibly safer to specify just '-name myfoo' rather directly the FQDN
 # ('-name myfoo@foo.example.com'), as we can check the name resolution used
 # by the VM (bogus values like '-name myfoo@ibm.com' would be accepted):
 #
 $ ERL_EPMD_PORT=4506 erl -name myfoo -setcookie abc -kernel inet_dist_listen_min 50000 inet_dist_listen_max 51000
 Erlang/OTP 27 [erts-15.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

 Eshell V15.2 (press Ctrl+G to abort, type help(). for help)
 (myfoo@foo.example.com)1>


And on ``bar.other.info``::

 $ killall epmd
 $ ERL_EPMD_PORT=4506 erl -name mybar@bar.other.info -setcookie abc -kernel inet_dist_listen_min 50000 inet_dist_listen_max 51000
 Erlang/OTP 27 [erts-15.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

 Eshell V15.2 (press Ctrl+G to abort, type help(). for help)
 (mybar@bar.other.info)1>


Then the following calls may be of interest, to interlink these VMs and check that they agree on interacting.

On ``foo.example.com``::

 1> net_adm:ping('mybar@bar.other.info').
 pong

And on ``bar.other.info``::

 1> net_adm:ping('myfoo@foo.example.com').
 pong


Then either of the two nodes can perform mostly anything on the other host (of course depending on the respective permissions of the users that run them); and of course Erlang cookies are not a security feature, they are just an ad hoc way of preventing unwanted interactions between nodes.



Troubleshooting
...............

The previous testing may have failed, and thus shall be investigated.

If wanting to start from a working configuration and gradually enrich it until reproducing that failure, just launch two shells on a given host, executing ``erl -name a@127.0.0.1 -setcookie hello`` on the first, and ``erl -name b@127.0.0.1 -setcookie hello`` on the second.

On the ``a`` (first) node, ``net_adm:ping('b@127.0.0.1')`` is expected to succeed, as, on the ``b`` (second) node, ``net_adm:ping('a@127.0.0.1')``. Use CTRL-C twice to exit both Erlang shells.

Then, in order to quick-check whether long-name connectivity is available and to rule out the most obvious culprits, for example in the first shell:

.. code:: bash

 # Check (with root permissions) that the firewall rules are safe; for example:
 $ iptables -nL
 Chain INPUT (policy ACCEPT)
 target     prot opt source               destination

 Chain FORWARD (policy ACCEPT)
 target     prot opt source               destination

 Chain OUTPUT (policy ACCEPT)
 target     prot opt source               destination

 # Just to be on the safer side for this test:
 $ killall beam.smp epmd

 # Then launch a new target first node:
 $ ERL_EPMD_PORT=4032 erl -name n1 -setcookie aa
 Erlang/OTP 23 [erts-11.1.4] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

 Eshell V11.1.4  (abort with ^G)
 (n1@hurricane.foobar.org)1>


In the second shell, try finding the previous node:

.. code:: bash

 $ ERL_EPMD_PORT=4032 erl -name n2 -setcookie aa
 Erlang/OTP 23 [erts-11.1.4] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

 Eshell V11.1.4  (abort with ^G)
 (n2@hurricane.foobar.org)1> net_adm:ping('n1@hurricane.foobar.org').
 pong


If you see ``pang`` here, run to the nearest altar and make a sacrifice to any Distribution God you may believe in (Norse ones being presumably the most effective here), and hunt down the failure causes listed in the next section.



Most Likely Causes of Node Connection Failures
..............................................

Way too often, for obscure reasons Erlang nodes fail to connect to each other (especially with long names), and little to no information is available to diagnose the issue: ``pang`` is received (instead of ``pong``), meaning that unfortunately the connection could not be created.

Among the many possible pitfalls, there are (approximately sorted by decreasing level of probability, according to our experience):

- at least a **firewall** between the two hosts filtering packets, either exchanged by the Erlang VMs (using ephemeral ports for that, within a possibly user-specified range), or by the EPMD daemons; one may refer to `our page about firewalls <Networking.html#firewall-management>`_; one may take inspiration for example from our `iptables.rules-FullDisabling.sh <https://github.com/Olivier-Boudeville/Ceylan-Hull/blob/master/iptables.rules-FullDisabling.sh>`_ script

- misconfigured (e.g. inconsistent) **naming / DNS** services (e.g. one host unable to resolve the other, or resolving it as a different name that it knows itself); simply running ``hostname -f``, and possibly ``ping foo.example.com`` from ``bar``, and ``ping bar.other.info`` from ``foo``, may unveil surprises; inspect both ``/etc/hosts`` files, which is often the scene of the disaster; if your hostname is ``hurricane`` and your domain is ``foobar.org``, then a line like the following one is known to work (whereas many variations of it may be deemed "incorrect"): ``127.0.0.1  hurricane.foobar.org hurricane localhost.localdomain localhost``, provided of course that, still in that file, you have not also a declaration such as ``192.168.0.5 hurricane.foobar.org hurricane`` (setting one's IP shall better be done in one's profile in ``/etc/netctl``, right?)

- inconsistent `EPMD <https://www.erlang.org/doc/apps/erts/epmd_cmd>`_ **ports** ; beware of any lingering ``ERL_EPMD_PORT`` environment variable that may still apply (this is why, in the example, one was specified; otherwise the default one, ``4369``, is expected to be relied upon)

- at least one incorrect (misspelled) **target node**; moreover their names must be atoms (hence the use of single quotes, as they comprise dots) and the FQDN should match (e.g. from the point of view of the EPMD daemon, ``bar`` and ``bar.other.info`` might be considered different)

- mistmatching (Erlang) **cookies** (of course): check that they use the same cookie, either from the start (use the ``-setcookie MY_COOKIE`` command-line option) or after having changed it after the VM was launched (use ``erlang:set_cookie/1`` for that / check with ``erlang:get_cookie/0``)

- mismatching **name addressing**: using short names (``-sname``) mixed with long names (``-name``)

- faulty EPMD **daemons** (e.g. one having missed that a node respawned; this seldom happens, under specific circumstances) - hence the prior killings in the example

- incompatible **versions** of Erlang (if in doubt, just use the latest stable one on either side); anyway such an issue should be reported on the console



With Our Conventions
--------------------

To focus a bit on developments relying on our conventions (notably the Ceylan-Myriad ones) about firewall settings, one may first inspect the ``/etc/iptables.settings-Gateway.sh`` file to check the firewall settings that are currently listed (e.g. ``grep 'myriad_default_epmd_port\|tcp_' iptables.settings-Gateway.sh``).

This may result for example in::

 myriad_default_epmd_port=4506
 enable_unfiltered_tcp_range="true"
 tcp_unfiltered_low_port=60000
 tcp_unfiltered_high_port=65000

(supposing they apply on both hosts)

One could ensure that these were indeed the ones applied (if ever the prior settings were changed yet with no firewall reloading afterwards), by checking the ``/root/.last-gateway-firewall-activation`` file.

Finally, one may run our ``iptables-inspect.sh`` script to request iptables to describe its current, actual state.

Then, to test the connectivity of corresponding VMs, first on ``foo.example.com``::

 $ killall epmd beam.smp
 $ ERL_EPMD_PORT=4506 erl -name myfoo@foo.example.com -setcookie abc -kernel inet_dist_listen_min 50000 inet_dist_listen_max 55000
 Erlang/OTP 27 [erts-15.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

 Eshell V15.2 (press Ctrl+G to abort, type help(). for help)
 (myfoo@foo.example.com)1>


And on ``bar.other.info``, this could be::

 $ export ERL_EPMD_PORT=4506
 $ erl -name mybar@bar.other.info -setcookie abc -kernel inet_dist_listen_min 50000 inet_dist_listen_max 55000
 Erlang/OTP 27 [erts-15.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

 Eshell V15.2 (press Ctrl+G to abort, type help(). for help)
 (mybar@bar.other.info)1> net_adm:ping('myfoo@foo.example.com').
 pong

At last it works!



About Security
==============

- one should not encrypt messages directly with a key pair (e.g. with RSA, only messages up to around 200 bytes long can be encrypted):  one should encrypt only a *symmetric key* (generated by a cryptographically-safe random algorithm) that is then used to encrypt one's message(s); ensure an Encrypt-Then-Authenticate scheme to prevent padding oracle attacks (and a secure-compare algorithm for the *Message Authentication Code* verification to prevent timing attacks); using `libsodium <https://doc.libsodium.org/>`_ should make mistakes using the standard crypto primitives less error-prone; see the `enacl <https://github.com/jlouis/enacl>`_ Erlang binding for that; for more information, refer to `the corresponding thread <https://erlangforums.com/t/cannot-encrypt-a-long-binary-using-public-key-encrypt-private-2/724>`_

- relevant sources of information:

  - books:

	- ``Cryptography Engineering: Design Principles and Practical Applications``
	- ``Practical Cryptography``

  - the `Security Working Group <https://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/>`_ of the EEF (*Erlang Ecosystem Foundation*)



OTP Guidelines
==============


The ``.app`` Specification
--------------------------

For an overall application named ``Foobar``, we recommend defining in ``conf/foobar.app.src`` an application specification template that, once properly filled regarding the version of  that application and the modules that it comprises (possibly automatically done thanks to the `Ceylan-Myriad <http://myriad.esperide.org>`_ logic), will result in an actual application specification file, ``foobar.app``.

Such a file is necessary in all cases, to generate an OTP application (otherwise with `rebar3 <http://rebar3.org/>`_ nothing will be built), an OTP release (otherwise the application dependencies will not be reachable), and probably an `hex <https://hex.pm/>`_ package as well.

This specification content is to end up in various places:

- in ``ebin/foobar.app``
- if using rebar3, in the OTP build tree (by default: ``./_build/lib/foobar/ebin/foobar.app``)
- with ``src/foobar.app.src`` being a symbolic link pointing to ``ebin/foobar.app`` (probably at least for hex)


Starting OTP Applications
-------------------------

For an OTP *active* application of interest - that is one that provides an actual service, i.e. running processes, as opposed to a mere *library* application, which provides only code - such a specification defines, among other elements, which module will be used to start this application. We recommend to name this module according to the target application and to suffix it with ``_app``, like in:

.. code:: erlang

 {application, foobar, [
	 [...]
	 {mod, {foobar_app, [hello]}},
	 [...]


This implies that once a user code will call ``application:start(foobar)``, then ``foobar_app:start(_Type=normal, _Args=[hello])`` will be called in turn.

This ``start/2`` function, together with its ``stop/1`` reciprocal, are the functions listed by the OTP (active) ``application`` behaviour; at least for clarity, it is better that ``foobar_app.erl`` comprises ``-behaviour(application).``


Pre-Launch Functions
-------------------

The previous OTP callbacks may be called by specific-purpose launching code; we tend to define an ``exec/0`` function for that: then, with the Myriad make system, executing on the command-line ``make foobar_exec`` results in ``foobar_app:exec/0`` to be called.

Having such a pre-launch function is useful when having to set specific information beforehand (see ``application:set_env/{1,2}``) and/or when starting by oneself applications (e.g. see ``otp_utils:start_applications/2``).

In any case this should result in ``foobar_app:start/2`` to be called at application startup, a function whose purpose is generally to spawn the root supervisor of this application.


Note that, alternatively (perhaps for some uncommon debugging needs), one may execute one's application (e.g. ``foo``) by oneself, knowing that doing so requires starting beforehand the applications it depends on - be them Erlang-standard (e.g. ``kernel, stdlib``) or user-provided (e.g. ``bar, buz``); for that both their modules [#]_ and their ``.app`` file [#]_ must be found.

.. [#] If using Ceylan-Myriad, run, from the root of ``foo``, ``make copy-all-beams-to-ebins`` to populate the ``ebin`` directories of all layers (knowing that by default each module is only to be found directly from its source/build directory, and thus such a copy is usually unnecessary).

.. [#] If using Ceylan-Myriad, run, from the root of ``foo``, ``make create-app-file``.


This can be done with:

.. code:: erlang

 $ erl -pa XXX/bar/ebin -pa YYY/buz/ebin -pa ZZZ/foo/ebin

 Erlang/OTP 26 [erts-14.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit:ns]

 Eshell V14.2 (press Ctrl+G to abort, type help(). for help)
 1> application:ensure_all_started([kernel, stdlib, bar, buz, foo]).



Then the ``foo`` application shall be launched, and a shell be available to interact with the corresponding VM.



OTP Supervisors
---------------

The purpose of supervisors is to ease the development of fault-tolerant applications by building hierarchical process structures called *supervision trees*.

For that, supervisors are to monitor their children, that may be workers (typically implementing the ``gen_{event,server,statem}`` behaviour) and/or other supervisors (they can thus be nested).

We recommend to define a ``foobar_sup:start_link/0`` function (it is an user-level API, so any name and arity can be used). This ``foobar_sup`` module is meant to implement the ``supervisor`` behaviour (to be declared with ``-behaviour(supervisor).``), which in practice requires an ``init/1`` function to be defined.

So this results, in ``foobar_sup``, in a code akin to:

.. code:: erlang

 -spec start_link() -> supervisor:startlink_ret().
 start_link() ->
	% This will result in calling init/1 next:
	supervisor:start_link( _Registration={local, my_foobar_main_sup},
						   _Mod=?MODULE, _Args=[]).

 -spec init(list()) -> {'ok', {supervisor:sup_flags(), [child_spec()]}}.
 init(_Args=[]) ->
	[...]
	{ok, {SupSettings, ChildSpecs}}.




Declaring Worker Processes
--------------------------

Our ``otp_utils`` module may help a bit defining proper restart strategies and child specifications, i.e. the information regarding the workers that will be supervised, here, by this root supervisor.

For example it could be:

.. code:: erlang

 init(_Args=[]) ->
	[...]
	SupSettings = otp_utils:get_supervisor_settings(
					_RestartStrategy=one_for_one, ExecTarget),
	% Always restarted in production:
	RestartSettings = otp_utils:get_restart_setting(ExecTarget),
	WorkerShutdownDuration =
		otp_utils:get_maximum_shutdown_duration(ExecTarget),
	% First child, the main Foobar worker process:
	MainWorkerChild = #{
		id => foobar_main_worker_id,
		start => {_Mod=foobar, _Fun=start_link,
				  _MainWorkerArgs=[A, B, C]},
		restart => RestartSettings,
		shutdown => WorkerShutdownDuration,
		type => worker,
		modules => [foobar] },
	ChildSpecs = [MainWorkerChild],
	{ok, {SupSettings, ChildSpecs}}.


Children are created synchronously and in the order of their specification [#]_.

.. [#] Yet some interleaving is possible thanks to ``proc_lib:init_ack/1``.


So if ``ChildSpecs=[A, B, C]``, then a child according to the A spec is first created, then, once it is over (either its ``init/1`` finished successfully, or it called ``proc_lib:init_ack/{1,2}`` [#]_ and then continued its own initialisation concurrently), a child according to the B spec is created, then once done a child according to the C spec.

.. [#] Typically: ``proc_lib:init_ack(self())``.



Implementing Worker Processes
-----------------------------

Such a worker, which can be any Erlang process (implementing an OTP behaviour, like ``gen_server``, or not) will thus be spawned here through a call to the ``foobar:start_link/3`` function (another user-defined API) made by this supervisor. This is a mere *call* (an ``apply/3``), not a spawn of a child process based on that function.

Therefore the called function is expected to *create* the worker process by itself, like, in the ``foobar`` module:

.. code:: erlang

 start_link(A, B ,C) ->
	[...]
	{ok, proc_lib:start_link(?MODULE, _Func=init,
		_Args=[U, V], _Timeout=infinity, SpawnOpts)}.

Here thus the spawned worker will start by executing ``foobar:init/2``, a function not expected to return, often trapping EXIT signals (``process_flag(trap_exit, true)``), setting system flags and, once properly initialised, notifying its supervisor that it is up and running (e.g. ``proc_lib:init_ack(_Return=self())``) before usually entering a tail-recursive loop.



Terminating Workers
-------------------

Depending on the ``shutdown`` entry of its child specification, on application stop that worker may be terminated by different ways. We tend to prefer specifying a maximum shutdown duration: then the worker will be sent by its supervisor first a ``shutdown`` EXIT message, that this worker may handle, typically in its main loop:

.. code:: erlang

 receive
	[...]

	{'EXIT', _SupervisorPid, shutdown} ->
	   % Just stop.
	   [...]


If the worker fails to stop (on time, or at all) and properly terminate, it will then be brutally killed by its supervisor.



Supervisor Bridges
------------------

Non-OTP processes (e.g. `WOOPER <http://wooper.esperide.org>`_ instances) can act as supervisors thanks to the `supervisor_bridge <https://www.erlang.org/doc/man/supervisor_bridge.html>`_ module.

Such a process shall implement the ``supervisor_bridge`` behaviour, namely ``init/1`` and ``terminate/2``. If the former function spawns a process, the latter shall ensure that this process terminates in a synchronous manner, otherwise race conditions may happen.

See `traces_bridge_sup <https://github.com/Olivier-Boudeville/Ceylan-Traces/blob/master/src/traces_bridge_sup.erl>`_ for an example thereof.



Extra Information
-----------------

One may refer to;

- `Ceylan-Myriad <http://myriad.esperide.org>`_ as an example of OTP *Library* Application
- `Ceylan-WOOPER <http://wooper.esperide.org>`_ or `Ceylan-Traces <http://traces.esperide.org>`_ as examples of OTP *Active* Applications
- `US-Web <http://us-web.esperide.org>`_ as an example of most of these supervisor principles





More Advanced Topics
====================


Metaprogramming
---------------

`Metaprogramming <https://en.wikipedia.org/wiki/Metaprogramming>`_ is to be done in Erlang through **parse transforms**, which are user-defined modules that transform an AST (for *Abstract Syntax Trees*, an Erlang term that represents actual code; see the `Abstract Format <https://www.erlang.org/doc/apps/erts/absform.html>`_ for more details) into another AST that is fed afterwards to the compiler.

See also:

- this `introduction to parse transforms <https://chlorophil.blogspot.com/2007/04/erlang-macro-processor-v1-part-i.html>`_
- Ceylan-Myriad's `support for metaprogramming <https://myriad.esperide.org/#support-for-metaprogramming>`_




Improper Lists
--------------

A proper list is created from the empty one (``[]``, also known as "nil") by appending (with the ``|`` operator, a.k.a. "cons") elements in turn; for example ``[1,2]`` is actually ``[1 | [2 | []]]``.

However, instead of enriching a list from the empty one, one *can* start a list with any other term than ``[]``, for example ``my_atom``. Then, instead of ``[2|[]]``, ``[2|my_atom]`` may be specified and will be indeed a list - albeit an improper one.

Many recursive functions expect proper lists, and will fail (typically with a function clause) if given an improper list to process (e.g. ``lists:flatten/1``).

So, why not banning such construct? Why even standard modules like ``digraph`` rely on improper lists?

.. inexact: The reason is that improper lists are a way to reduce the memory footprint of some datastructures, by storing a value of interest (provided that it fits here as an immediate value, i.e. roughly that this value is no larger than a pointer) instead of the empty list.

The reason is that improper lists are a way to reduce the memory footprint of some datastructures, by storing a value of interest instead of the empty list.


Indeed, as explained `in this post <https://groups.google.com/g/erlang-programming/c/mQLS5yGX_8g/m/Ad4VVyOUDQAJ>`_, a (proper) list of 2 elements will consume:

- 1 list cell (2 words of memory) to store the first element and a pointer to second cell
- 1 list cell (2 more words) to store the second element and the empty list

For a total of 4 words of memory (so, on a 64-bit architecture, it is 32 bytes).

As for an improper list of 2 elements, only 1 list cell (2 words of memory) will be consumed to store the first element and then the second one.

Such a solution is even more compact than a pair (a 2-element tuple), which consumes 2+1 = 3 words. Accessing the elements of an improper list is also faster (one handle to be inspected vs also an header to be inspected).

Finally, for sizes expressed in bytes:

.. code:: erlang

 1> system_utils:get_size([2,my_atom]).
 40

 2> system_utils:get_size({2,my_atom}).
 32

 3> system_utils:get_size([2|my_atom]).
 24


See also the `1 <http://beam-wisdoms.clau.se/en/latest/indepth-memory-layout.html#lists-cons>`_, `2 <http://beam-wisdoms.clau.se/en/latest/indepth-data-sizes.html#list>`_ pointers for more information.

Everyone shall decide on whether relying on improper lists is a trick, a hack or a technique to prohibit.



OpenCL
------

`Open Computing Language <https://en.wikipedia.org/wiki/OpenCL>`_ is a standard interface designed to program many processing architectures, such as CPUs, GPUs, DSPs, FPGAs.

OpenCL is notably a way of using one's GPU to perform more general-purpose processing than typically the rendering operations allowed by `GLSL <ThreeDimensional.html#glsl>`_ (even compared to its compute shaders).

In Erlang, the `cl binding <https://github.com/tonyrog/cl>`_ is available for that.

A notable user thereof is `Wing3D <ThreeDimensional.html#wings3d>`_; one may refer to the ``*.cl`` files in `this directory <https://github.com/dgud/wings/tree/master/shaders>`_, but also to its optional build integration as a source of inspiration, and to `wings_cl.erl <https://github.com/dgud/wings/blob/master/src/wings_cl.erl>`_.



Post-Mortem Investigations
--------------------------

Erlang programs may fail, and this may result in mere (Erlang-level) crashes (the VM detects an error, and reports information about it, possibly in the form of a crash dump) or (sometimes, quite infrequently though) in more brutal, lower-level core dumps (the VM crashes as a whole, like any faulty program run by the operating system); this last case happens typically when relying on faulty `NIFs <https://www.erlang.org/doc/tutorial/nif.html>`_.



Monitoring
..........

To monitor a (live, Erlang) application, one may use:

- the (integrated) `observer <https://www.erlang.org/doc/apps/observer/observer_ug>`_ graphical tool (either locally, or remotely with ``observer:start/1``)
- an headless (command-line) observer: `observer_cli <https://hexdocs.pm/observer_cli/>`_
- a monitoring and introspection application: `system_monitor <https://github.com/ieQu1/system_monitor>`_
- an `observer web frontend <https://github.com/systra/ObserverWeb>`_



Erlang Crash Dumps
..................

If experiencing "only" an Erlang-level crash, a ``erl_crash.dump`` file is produced in the directory whence the executable (generally ``erl``) was launched. The best way to study it is to use the ``cdv`` (refer to `crashdump viewer <https://www.erlang.org/doc/apps/observer/crashdump_ug.html>`_) tool, available, from the Erlang installation, as ``lib/erlang/cdv`` [#]_.

.. [#] Hence, according to the Ceylan-Myriad conventions, in ``~/Software/Erlang/Erlang-current-install/lib/erlang/cdv``.

Using this debug tool is as easy as:

.. code:: bash

 $ cdv erl_crash.dump

Then, through the wx-based interface, a rather large number of Erlang-level information will be available (processes, ports, ETS tables, nodes, modules, memory, etc.) to better understand the context of this crash and hopefully diagnose its root cause.



Core Dumps
..........

In the worst cases, the VM will crash like any other OS-level process, and generic (non Erlang-specific) tools will have to be used. Do not expect to be pointed to line numbers in Erlang source files anymore!

Refer to our general section dedicated to `core dumps <GNULinux.html#core-dumps>`_ for that.



Language Bindings
=================

The two main approaches in order to integrate third-party code to Erlang are to:

- interact with it as if it was another Erlang node; we defined `Ceylan-Seaplus <http://seaplus.esperide.org>`_ for that purpose, to simplify the binding of C code; other libraries provide link to various languages

.. _`nif`:

- directly link the current Erlang VM to this code, through `NIF <https://www.erlang.org/doc/tutorial/nif.html>`_; for C, it can be done manually, or may be automatised thanks to `nifty <https://github.com/parapluu/nifty>`_, which is an *Erlang NIF Wrapper Generator*; this can be especially useful for larger APIs (e.g. `SDL <https://www.libsdl.org/>`_); see also `rusterl <https://docs.rs/rustler/latest/rustler/pub>`_, which allows to write NIFs in safe Rust code

.. python bindings: erlport, https://pyrlang.github.io/Pyrlang/



Language Implementation
=======================


Message-Passing: Copying vs Sharing
-----------------------------------

Knowing that, in functional languages such as Erlang, terms ("variables") are immutable, why could not they be shared between local processes when sent through messages, instead of being copied in the heap of each of them, as it is actually the case with the Erlang VM?

The reason lies in the fact that, beyond the constness of these terms, their life-cycle has also to be managed. If they are copied, each process can very easily perform its (concurrent, autonomous) garbage collections. On the contrary, if terms were shared, then reference counting would be needed to deallocate them properly (neither too soon nor never at all), which, in a concurrent context, is bound to require locks.

So a trade-off between memory (due to data duplication) and processing (due to lock contention) has to be found and at least for most terms (excepted larger binaries), the sweet spot consists in sacrificing a bit of memory in favour of a lesser CPU load. Solutions like `persistent_term <https://www.erlang.org/doc/man/persistent_term.html>`_ may address situations where more specific needs arise.


.. _JIT:

Just-in-Time Compilation
------------------------

This long-awaited feature, named *BeamAsm* and whose rationale and history have been detailed in `these articles <https://www.erlang.org/blog/the-road-to-the-jit/>`_, has been introduced in Erlang 24 and shall transparently lead to increased performances for most applications.




Static Typing
-------------

Static type checking can be performed on Erlang code; the usual course of action is to use `Dialyzer <https://www.erlang.org/doc/man/dialyzer.html>`_ - albeit other solutions like `Gradualizer <https://github.com/josefs/Gradualizer>`_ and also `eqWAlizer <https://github.com/WhatsApp/eqwalizer>`_ exist, and are mostly complementary (see also `1 <https://learnyousomeerlang.com/types-or-lack-thereof#for-type-junkies>`_ and `2 <https://learnyousomeerlang.com/dialyzer>`_).

More precisely:

- Dialyzer is a discrepancy analyzer that aims **to prove the presence of type-induced runtime crashes** (it may not be able to detect all type problems, yet "is never wrong"); Dialyzer does not use type specifications to guide the analysis: first it infers type information, and then only, if requested, it checks that information against the type specifications; so Dialyzer may operate with or without type specifications
- whereas tools like Gradualizer and eqWAlizer are more conventional type systems, based on the theory of gradual typing, that aim **to prove the absence of such crashes**; notably Gradualizer depends intimately on type specifications: by default, without them, no static typing happens

See `EEP 61 <https://www.erlang.org/eeps/eep-0061>`_ for further typing-related information [#]_.

.. [#] On a side note, the (newer) ``dynamic()`` type mentioned there is often used to mark "inherently dynamic code", like reading from ETS, message passing, deserialization and so on.


Also a few `statically-typed languages <https://github.com/llaisdy/beam_languages#statically-typed-languages>`_ can operate on top of the Erlang VM, even if none has reached yet the popularity of Erlang or Elixir (that are dynamically-typed).

In addition to the increased type safety that statically-typed languages permit (possibly applying to sequential code but also to inter-process messages), it is unsure whether such extra static awareness may also lead to better performances (especially now that the standard compiler supports JIT_).

Beyond mere code, the messages exchanges between processes could also be typed and checked. Version upgrades could also benefit from it. Of course type-related errors are only a subset of the software errors.

Note that developments that rely on parse-transforms (almost all ours, directly or not) shall be verified based on their BEAM files (hence their actual, final output) rather than on their sources (as the checking would be done on code not transformed yet). See also the `Type-checking Myriad <https://myriad.esperide.org/#type-checking-myriad>`_ section.



About Dialyzer
..............


Installing Dialyzer
___________________

Nothing is to be done, as Dialyzer is included in the standard Erlang distribution.


Using Dialyzer
______________

Our preferred options (beyond path specifications of course) are: ``-Wextra_return -Wmissing_return -Wno_return -Werror_handling -Wno_improper_lists -Wno_unused -Wunderspecs``. See the ``DIALYZER_OPTS`` variable in Myriad's `GNUmakevars.inc <https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/GNUmakevars.inc>`_ and the copiously commented options.

A problem is that typing errors tend to snowball: many false positives (functions that are correct but whose call is not because an error upward in the callgraph) may be reported (leading to the infamous ``Function f/N has no local return``, which does not tell much).

We recommend focusing on the first error reported for each module, and re-running the static analysis once supposedly fixed.



About Gradualizer
.................


Installing Gradualizer
______________________

We install `Gradualizer <https://github.com/josefs/Gradualizer>`_ that way:

.. code:: bash

 $ cd ~/Software
 $ mkdir gradualizer && cd gradualizer
 $ git clone https://github.com/josefs/Gradualizer.git
 $ cd Gradualizer
 $ make escript

Then just ensure that the ``~/Software/gradualizer/Gradualizer/bin`` directory is in your PATH (e.g. set in your ``.bashrc``).


Using Gradualizer
_________________

Our preferred options (beyond path specifications of course) are: ``--infer --fmt_location verbose --fancy --color always --stop_on_first_error``. See the ``GRADUALIZER_OPTS`` variable in Myriad's `GNUmakevars.inc <https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/GNUmakevars.inc>`_ and the copiously commented options..



About eqWAlizer
...............

It is a tool developed in Scala. It operates on Erlang source files (thus not on BEAM ones).



Installing eqWAlizer
____________________

Now we build it from sources with ELP, refer to the `ELP From Sources`_ section.

Alternatively we used to install `eqWAlizer <https://github.com/WhatsApp/eqwalizer>`_ that way:

.. code:: bash

 $ cd ~/Software
 $ mkdir -p eqwalizer && cd eqwalizer
 $ wget https://github.com/WhatsApp/eqwalizer/releases/download/vx.y.z/elp-linux.tar.gz
 $ tar xvf elp-linux.tar.gz && mkdir -p bin && /bin/mv -f elp bin/


Then just ensure that the ``~/Software/eqwalizer/bin`` directory is in your PATH (e.g. set in your ``.bashrc``).



Using eqWAlizer
_______________

We use it out of a rebar3 context.

Settings are to be stored in a JSON file (e.g. ``conf/foobar-for-eqwalizer.json``), to be designated thanks to the ``--project`` option.

See also the ``EQWALIZER_OPTS`` variable in Myriad's `GNUmakevars.inc <https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/GNUmakevars.inc>`_ and its own `myriad-for-eqwalizer.json <https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/conf/myriad-for-eqwalizer.json>`_  project file.

(our first test was not successful, we will have to investigate more when time permits)



Software Robustness
-------------------

Type correctness is essential, yet of course it does not guarantee that a program is correct and relevant. Other approaches, like the **checking** of other properties (notably concurrency, see `Concuerror <https://github.com/parapluu/Concuerror>`_) can be very useful.

Beyond checking, **testing** is also an invaluable help for bug-fixing. Various tools may help, including `QuickCheck <http://www.quviq.com/products/erlang-quickcheck/>`_.

Finally, not all errors can be anticipated, from network outages, hardware failures to human factor. An effective last line of defence is to rely on (this time at runtime) **supervision mechanisms** in order to detect any kind of faults (bound to happen, whether expected or not), and overcome them. The OTP framework is an excellent example of such system, much useful to reach higher levels of robustness, including the well-known nine nines - that is an availability of 99.9999999%.



Intermediate Languages
----------------------

To better discover the inner workings of the Erlang compilation, one may look at the `eplaypen online demo <http://tryerl.seriyps.ru/>`_ (whose project is `here <https://github.com/seriyps/eplaypen>`_) and/or at the `Compiler Explorer <https://godbolt.org/>`_ (which supports the Erlang language among others).

Both of them allow to read the intermediate representations involved when compiling Erlang code (BEAM stage, erl_scan, preprocessed sources, abstract code, Core Erlang, Static Single Assignment form, BEAM VM assembler opcodes, x86-64 assembler generated by the JIT, etc.).




Short Hints
===========


Properly Commenting
-------------------

As far as we understand, the best practice is to rely on:

- `EDoc <https://www.erlang.org/doc/apps/edoc/chapter.html>`_, yet without relying on the syntax exposed in that link (not even its `wiki notation <https://www.erlang.org/doc/apps/edoc/chapter#Wiki_notation>`_), but according to the next point (i.e. the Markdown syntax)
- the `new -moduledoc / -doc attributes <https://www.erlang.org/eeps/eep-0059#new-module-attributes>`_, which are replacements for EDoc style comments; refer to this `documentation page <https://www.erlang.org/doc/system/documentation.html>`_ to make good use of them; in a nutshell, we recommend using the default format for documentation attributes, Markdown, whose actual syntax is summarised for example in `this page <https://www.markdownguide.org/basic-syntax/>`_
- documentation text in which verbatim quoting is therefore done by enclosing the target text with ````` (i.e. a single backquote, on both sides - even if, for some reason, `this section <https://www.erlang.org/doc/apps/edoc/chapter#verbatim-quoting>`_ promotes ```'``), as suggested by the `Erlang/OTP sources themselves <https://github.com/erlang/otp/blob/master/lib/kernel/src/inet.erl#L70>`_; so documentation may include for example ```gethostbyaddr/1``` or ```"150.236.20.73"```
- named hypertext links are in the form of ``[displayed text](http://foobar.html)``, otherwise a link to be displayed verbatim may just be specified as ``[http://foobar.html]``

As a reminder of the syntax that ``-moduledoc`` / ``-doc`` attributes support (note the ``m/t/c`` prefixes):

.. code:: erlang

 -moduledoc """
   A module for **basic arithmetic**.

   This module can be used to add and subtract values. For example:

   ```erlang
   1> arith:subtract(arith:add(2, 3), 1).
   4
   ```

   See `sub/2` or `arith:subtract/2`, and the `m:arith` module for more details.

   In terms of types, refer to `t:number/0` and `t:arith:number/0` for more details.

   In terms of callbacks, refer to `c:increment/0` and `c:arith:increment/0` for more details.
   """.

Extra pages (e.g. ``notes.md``) may be defined and referenced.

The availability of such documentation can be tested from a shell, with for example ``1> h(arith).`` or ``h(arith, add)``.

Failure to properly specify comments is bound to mess with the syntax highlighting (at least with `Emacs <Emacs.html#regarding-erlang>`_).



Performing Local Returns
------------------------

Quite often we would like to be able to write code with conditions able to shortcut like:

.. code:: erlang

  f(A) ->

	Res = case g(A) of

	  % Wanting this clause to stop the processing here:
	  X ->
		return something(X); % Yet 'return' does not exist.

	  Y ->
		h(Y)

	end,
	i(Res),
	[...]
	some_expression().

  U = f(12),
  k(U),
  [...]


One can consider here that ``g/1`` allows to detect specific cases like ``X`` that shall stop the processing, and that, in the general case, multiple of such conditions are to be checked (e.g. with ``g1/1``, ``g2/1``, etc.), each possibly with a different outcome.

However there is no ``return`` operator in Erlang, and thus by default the ``X`` branch cannot finish without ``i/1`` being called and the rest of the expressions below being evaluated.

If ever ``g/1`` could be expressed as a guard expression (which is not that common, since the expressiveness of Erlang guards is quite limited), then **pattern-matching** could be used at the level of ``f/1``, at the expense of some refactoring.

Otherwise, a solution would be to **nest cases**, i.e. to append at the end of the ``Y`` branch the whole section starting with the ``i/1`` call. Yet, at each new condition, the whole code would gain one nesting level and be indented more on the right, and cascading like this is not desirable (as quickly not readable).

Yet it should be known that the ``throw/1`` BIF (*Built-In Function*), which raises an exception of class ``throw``, is not specifically dedicated to error management: as stated `in its documentation <https://www.erlang.org/doc/apps/erts/erlang#throw/1>`_, it is more generally intended to be used to perform **non-local returns** from functions.

So the previous example could be transformed in:

.. code:: erlang

  f(A) ->

	try:

	  Res = case g(A) of

		X ->
		  throw(something(X));

		Y ->
		  h(Y)

	  end,
	  i(Res),
	  [...]
	  some_expression()

	catch

	  throw:Something ->
		Something

	end.

  U = f(12),
  k(U),
  [...]


Doing so adds a single level of nesting (for the ``try/catch``), regardless of the number of shortcut conditions to consider, and let them be handled specifically if needed (thanks to any pattern-matching done in the ``catch`` clause).

However such use of ``throw/1`` may not seem so easy, natural or possibly very efficient (stack unwinding?), and at least some developers prefer staying away from using it for non-error branching (i.e. for local returns [#]_).

.. [#] Actually, more generally, some consider that relying on local returns is a bad practice in itself (less readable, more imperative-like).


So, quite often, in our opinion, the best remaining option - even if it is not very satisfactory (heavy, long), is to **define extra (helper) functions** like ``h_helper/1`` in:

.. code:: erlang

  f(A) ->

	Res = case g(A) of

	  X ->
		something(X);

	  Y ->
		h_helper(Y)

	end.

  h_helper(Z) ->
	i(Z),
	[...]
	some_expression().

  U = f(12),
  k(U),
  [...].



Dealing with Conditional Availability
-------------------------------------


Regarding modules, and from the command-line
............................................

Depending on how Erlang was built in a given environment, some modules may or may not be available.

A way of determining availability and/or version of a module (e.g. ``wx``, ``cl``, ``crypto``) from the command-line:

.. code:: bash

 $ erl -noshell -eval 'erlang:display(code:which(wx))' -s erlang halt
 "/home/bond/Software/Erlang/Erlang-24.2/lib/erlang/lib/wx-2.1.1/ebin/wx.beam"

 $ erl -noshell -eval 'erlang:display(code:which(cl))' -s erlang halt
 non_existing

A corresponding in-makefile test, taken from Wings3D:

.. code:: makefile

 # Check if OpenCL package is as external dependency:
 CL_PATH = $(shell $(ERL) -noshell -eval 'erlang:display(code:which(cl))' -s erlang halt)
 ifneq (,$(findstring non_existing, $(CL_PATH)))
	# Add it if not found:
	DEPS=cl
 endif



Regarding language features, from code
......................................

Some features appeared in later Erlang versions, and may be conditionally enabled.

For example:

.. code:: erlang

 FullSpawnOpts = case erlang:system_info(version) >= "8.1" of

	true ->
		[{message_queue_data, off_heap}|BaseSpawnOpts];

	false ->
		BaseSpawnOpts

 end,
 [...]



Runtime Library Version
-----------------------

To know **which version of a library** (here, wxWidgets) a given Erlang install is using (if any), one may run an Erlang shell (``erl``), collect the PID of this (UNIX) process (e.g. ``ps -edf | grep beam``), then trigger a use of that library (e.g. for ``wx``, execute ``wx:demo().``) in order to force its dynamic binding.

Then determine its name, for example thanks to ``pmap ${BEAM_PID} | grep libwx``).

This may indicate that for example ``libwx_gtk2u_core-3.0.so.0.5.0`` is actually used.



Proper In-Program Naming
------------------------

These are some conventions that we recommend.


Variable Shorthands
...................

Usually we apply the following conventions:

- the *head* and *tail* of a list are designated as ``H`` and ``T`` (and possibly ``L``), like in: ``L = [H|T]``
- ``Acc`` means *accumulator*, in a tail-recursive function
- ``P`` designates a *pair* (a tuple of two elements)
- ``K`` designates a *key*, and ``V`` designates its associated *value*
- longer (type-related) names shall be abbreviated; for example a "canonical incoming trigger specification" may result in the ``canon_incoming_trigger_spec/0`` type, and a variable of that type may be named ``CITS``
- a list of elements is designated by a plural variable name, usually suffixed with ``s``, like in: ``Ints``, ``Xs``, ``Xss`` (list of lists of X), ``Cars``



Function Pairs
..............

To better denote reciprocal operations, following namings for functions may be used:

- for services:

  - activation: ``start`` / ``stop``
  - setup: ``init`` / ``terminate``

- for instances:

  - life-cycle: ``new`` / ``delete``
  - construction/destruction: ``create`` / ``destruct`` (e.g. avoid ``destroy`` there)




Formatting Erlang Code
----------------------

Various tools are able to format Erlang code, see `this page <https://github.com/WhatsApp/erlfmt/blob/main/doc/ErlangFormatterComparison.md>`_ for a comparison thereof.


With ``rebar3_format``
......................

For projects already relying on rebar, one may use `rebar3_format <https://github.com/AdRoll/rebar3_format>`_ (as a plugin [#]_) that way:

.. code:: shell

 $ cd ~/Software
 $ git clone https://github.com/AdRoll/rebar3_format.git
 $ cd rebar3_format
 $ ERL_FLAGS="-enable-feature all" rebar3 format

.. [#] Note that ``rebar3_format`` cannot be used as an escript (so no ``ERL_FLAGS="-enable-feature all" rebar3 as release escriptize`` shall be issued).

Then ``{project_plugins, [rebar3_format]}`` shall be added to the project's ``rebar.config``.



With ``erlfmt``
...............

Another tool is `erlfmt <https://github.com/WhatsApp/erlfmt>`_, which can be installed that way:

.. code:: shell

 $ cd ~/Software
 $ git clone https://github.com/WhatsApp/erlfmt
 $ cd erlfmt
 $ rebar3 as release escriptize

And then ``~/Software/erlfmt/_build/release/bin`` can be added to one's ``PATH``.

Indeed ``erlfmt`` can be used as a rebar plugin or as a standalone escript - which we find useful, especially for projects whose build is not rebar-based.

Running it to reformat in-place source files is then as simple as:

.. code:: shell

 $ erlfmt --write foo.hrl bar.erl



Language Features
-----------------

Experimental features (such as ``maybe`` in Erlang 25) of the **compiler** (once Erlang has been built, they are *potentially available*) may have to be specifically *enabled* at runtime, like in ``ERL_FLAGS="-enable-feature all" rebar3 as release escriptize``.



Disabling LCO
-------------

LCO means here *Last Call Optimisation*. This consists simply when, in a given module, a (typically exported) function ``f`` ends by calling a *local* function ``g`` (i.e. has for last expression a call like ``g(...)``), in not pushing on the stack the call to ``g``, but instead replacing directly the stackframe of ``f`` (which can be skipped here, as returning from ``g`` will mean directly returning from ``f`` as well) with a proper one for ``g``.

This trick spares the use of one level of stack at each ending local call, which is key for recursive functions [#]_ (typically for infinitely-looping server processes): they remain then in constant stack space, whereas otherwise the number of their stackframes would grow indefinitely, at each recursive call, and explode in memory.

.. [#] When the last call of ``f`` branches to ``f`` itself, it is named TCO, for *Tail Call Optimisation* (which is thus a special - albeit essential - case of LCO).

So LCO is surely not an option for a functional language like Erlang, yet it comes with a drawback: if ``f`` ends with a last call to ``g`` that ends with a last call to ``h`` and a runtime error happens in them, none of these functions will appear in the resulting stacktraces: supposing all these functions use a library ``foobar``, it will be as if the VM directly jumped from the entry point in the user code (typically a function calling ``f``) to the failing point in a function of ``foobar``; there will be no line number pointing to the expression of ``f``,  ``g`` or ``h`` that triggers the faulty behaviour, whereas this is probably the information we are mostly interested in - as these functions may make numerous calls to ``foobar``'s function. This makes the debugging unnecessarily difficult.

Yet various workarounds exist (see `this topic <https://erlangforums.com/t/disabling-tco-selectively/3091>`_ for more information) - just for debugging purposes - so that given "suspicious" functions (here ``f``,  ``g`` or ``h``) are not LCO'ed:

- to have their returned values wrapped in a remote call to an identity function (we use ``basic_utils:identity/1`` for that)
- or to have them wrapped (at least their end, i.e. their last expression(s)) with ``try ... catch E -> throw(E) end``
- or to return-trace these functions, as it temporarily disables LCO and allows to be very selective (one can limit this to a specific process or certain conditions, with match specs; refer to `dbg <https://www.erlang.org/doc/man/dbg.html>`_ for more details; note that the module of interest must be compiled with ``debug_info`` so that it can be traced)

The first workaround is probably the simplest, when operating on "suspicious" modules of interest (knowing that LCO *is* useful, and should still apply to most essential server-like processes).

One can nevertheless note that unfortunately LCO is not the only cause for the vanishing of calls in the stacktrace (even in the absence of any function inlining).

Within `Ceylan-Myriad <http://myriad.esperide.org>`_, if the (non-default) ``myriad_disable_lco`` compilation option is set (typically with the ``-Dmyriad_disable_lco`` command-line flag), this workaround is applied automatically on the modules on which the Myriad parse transform operates - i.e. all but bootstrapped modules (refer to the ``lco_disabling_clause_transform_fun/2`` function of the `myriad_parse_transform <https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/src/meta/myriad_parse_transform.erl>`_ module).



Using ``run_erl/to_erl``
------------------------

When using `run_erl <https://www.erlang.org/docs/26/man/run_erl.html>`_, lines like the following are output::

 Write pipe '/tmp/launch-erl-3822033.w' found, waiting 2 seconds to ensure start-up is successful indeed.

  **************************************************************
  ** Node 'us_main' ready and running as a daemon.
  ** Use 'to_erl /tmp/launch-erl-3822033' to connect to that node.
  ** (then type CTRL-D to exit without killing the node)
  **************************************************************
  (authbind success reported)

 EPMD names output (on default US-Main port ):
 epmd: up and running on port 4507 with data:
 name us_main at port 50002
 name us_main_exec-xxx at port 60001


If connecting to that node with ``to_erl /tmp/launch-erl-3822033`` (hence from the local host), a direct access to an Erlang shell on that node is granted.

Remember that exiting the interpreter as usual (hitting CTRL-C twice) thus means killing that node; so prefer CTRL-D (once) instead!





Using wx
--------

`wx <https://www.erlang.org/doc/man/wx.html>`_ is now [#]_ the standard Erlang way of programming one's graphical user interface; it is a binding to the `wxWidgets <http://www.wxwidgets.org/>`_ library.

.. [#] ``wx`` replaced `gs <https://www.erlang.org/docs/18/man/gs.html>`_. To shelter already-developed graphical applications from any future change of backend, we developed `MyriadGUI <https://myriad.esperide.org/#graphical-user-interface-gui>`_, an interface doing its best to hide the underlying graphical backend at hand: should the best option in Erlang change, that API would have to be ported to the newer backend, hopefully with little to (ideally) no change in the user applications.

Here are some very general wx-related information that may be of help when programming GUIs with this backend:

- in wxWidgets parlance, "window" designates any kind of widget (not only frame-like elements)

- if receiving errors about ``{badarg,"This"}``, like in:

.. code:: erlang

 {'_wxe_error_',710,{wxDC,setPen,2},{badarg,"This"}}

it is probably the sign that the user code attempted to perform an operation on an already-deallocated wx object; the corresponding life-cycle management might be error-prone, as some deallocations are implicit, others are explicit, and in a concurrent context race conditions easily happen

- if creating, from a wx-using process, another one, this one should set a relevant environment first (see ``wx:set_env/1``) before using wx functions

- the `way wx/wxWidgets manage event propagation <https://docs.wxwidgets.org/latest/overview_events.html#overview_events_propagation>`_ is complex; here are some elements:

  - for each actual event happening, wx creates an instance of `wxEvent <https://docs.wxwidgets.org/latest/classwx_event.html>`_ (a direct, abstract child class of ``wxObject``), which itself is specialised into many event classes that are more concrete

  - among them, they are so-called *command events*, which originate from a variety of simple controls and correspond to the `wxCommandEvent <https://docs.wxwidgets.org/latest/classwx_command_event.html>`_ mother class; by default only these command events are set to propagate, i.e. only them will be transmitted to the event handler of the parent widget if the current one does not process them by itself ("did not connect to them")

  - by default, for a given type of event, when defining one's event handler (typically when connecting a process to the emitter of such events), this event will *not* be propagated anymore, possibly preventing the built-in wx event handlers to operate (e.g. to properly manage resizings); to restore their activation, ``skip`` (to be understood here as "propagate event" - however counter-intuitive it may seem) shall be set to ``true`` (either by passing a corresponding option when connecting, or by calling ``wxEvent:skip/2`` with ``skip`` set to ``true`` from one's event handler) [#]_

  - when a process connects to the emitter of a given type of events (e.g. ``close_window`` for a given frame), this process is to receive corresponding messages and then perform any kind of operation; however these operations cannot be synchronous (they are non-blocking: the process does not send to anyone any notification that it finished handling that event), and thus, if ``skip`` is ``true`` (that is, if event propagation is enabled), any other associated event handler(s) will be triggered concurrently to the processing of these event messages; this may be a problem for example if a controller listens to the ``close_window`` event emitted by a main frame in order to perform a proper termination: the basic, built-in event handlers will then by default be triggered whereas the controller teardown may be still in progress, and this may result in errors (e.g. OpenGL ones, like ``{{{badarg,"This"},{wxGLCanvas,swapBuffers,1}},...`` because the built-in close handlers already deallocated the OpenGL context); a proper design is to ensure that ``skip`` remains set to false so that propagation of such events is disabled in these cases: then only the user code is in charge of closing the application, at its own pace [#]_


.. [#] MyriadGUI took a different convention: whether an event will propagate by default depends on its type, knowing that most of the types are to propagate. Yet the user can override these default behaviours, by specifying either the ``trap_event`` or the ``propagate_event`` subscription option, or by calling either the ``trap_event/1`` or the ``propagate_event/1`` function.

.. [#] This is why MyriadGUI applies per-event type defaults, thus possibly trapping events; in this case, if the built-in backend mechanisms would still be of use, they can be triggered by calling the ``propagate_event/1`` function from the user-defined handler, only once all its prerequisite operations have been performed (this is thus a way of restoring sequential operations).


.. comment: we experienced segmentation faults in some cases (e.g. when calling there ``wxFrame:new()`` - whereas calling ``wxFrame:new(wx:null(), ?wxID_ANY, "Hello")`` would work correctly; no ``wxWindow`` could be created either as a wxWidgets assertion would fail, because a non-NULL parent was needed)

- in terms of sizing, the dimensions of a parent widget prevail: its child widgets have to adapt (typically with sizers); if wanting instead that the size of a child dictates the one of its parent, the size of the client area of the parent should be set to the best size of its child, or its ``fit/1`` method shall be called

Extra information resources about ``wx`` (besides the documentation of its modules):

- the graphical `class hierarchy of the wxWindow class <https://docs.wxwidgets.org/latest/classwx_window.html>`_, as this class corresponds to the concept of widget, which is very central
- `graphical repositories of most widgets <https://docs.wxwidgets.org/latest/page_screenshots.html>`_ (screenshots thereof)

- wxErlang: `Getting started <https://arifishaq.files.wordpress.com/2017/12/wxerlang-getting-started.pdf>`_ and `Speeding up <https://arifishaq.files.wordpress.com/2018/04/wxerlang-speeding-up.pdf>`_, by Arif Ishaq

- Doug Edmunds' `wxerlang workups <http://wxerlang.dougedmunds.com/>`_

- `wxWidgets itself <https://www.wxwidgets.org/>`_

.. comment 404: - http://www.idiom.com/~turner/wxtut/wxwidgets.html



Using a LSP language server for Erlang
--------------------------------------

We used to rely on `erlang_ls <https://erlang-ls.github.io/>`_, which is archived (unmaintained) now; we prefer using `ELP <https://whatsapp.github.io/erlang-language-platform/>`_, i.e. the so-called *Erlang Language Platform* now.



Installing ELP
..............



ELP From Sources
________________

This is the approach that we recommend.

We mostly follow `these guidelines here <https://whatsapp.github.io/erlang-language-platform/docs/get-started/install/#from-source/>`_.

Relying on a installation from sources implies the build of `eqWAlizer <https://github.com/WhatsApp/eqwalizer>`_, which itself, being Scala-based, requires:

- Java 11 or more recent (if using LogMX, see `this page <https://traces.esperide.org/#requested-widths-for-logmx-entry-columns-not-honored>`_), which we can obtain (based on OpenJDK) on Arch with ``pacman -S jdk-openjdk`` and that we select based on the output of ``archlinux-java status``, leading to execute for example: ``archlinux-java set java-24-openjdk`` (check then the actual version with ``java -version``)
- `sbt <https://github.com/sbt/sbt>`_ (*a build tool for Scala, Java, and more*), which can be obtained on Arch with ``pacman -S sbt``.

.. sbt may be difficult to obtain.


Once these prerequisite are available, eqWAlizer can be built:

.. code:: bash

 $ mkdir ~/Software
 $ cd ~/Software

 # Or, just to update: cd eqwalizer && git pull
 $ git clone https://github.com/WhatsApp/eqwalizer.git

 # If not building from the main branch: git tag -l && git checkout vx.y.z
 $ pushd eqwalizer/eqwalizer
 $ sbt assembly
 $ popd

 # May find for example
 # eqwalizer/eqwalizer/target/scala-3.6.4/eqwalizer.jar:
 $ find eqwalizer -name eqwalizer.jar


Then in one's  ``~/.bashrc`` for example, supposing a single version of such a build exists, one may declare, so that the next ELP build can find this eqwalizer one::

  export ELP_EQWALIZER_PATH="$(/bin/ls -t ${HOME}/Software/eqwalizer/eqwalizer/target/scala-*/eqwalizer.jar 2>/dev/null | head -n 1)"


Then ELP shall be built, which requires sufficiently recent Rust and cargo (notably for the `edition2024` feature; on Arch, ``pacman -S cargo`` shall suffice).

.. code:: bash

 $ cd ~/Software

 # Or, just to update: cd erlang-language-platform && git pull
 $ git clone https://github.com/WhatsApp/erlang-language-platform.git

 $ cd erlang-language-platform

 # This will be long, and may overheat one's CPU, so use either:
  $ cargo build --release
 # Or: cpulimit --limit 100 cargo build --release


Then in one's  ``~/.bashrc`` for example, one may declare::

  export PATH="${HOME}/Software/erlang-language-platform/target/release:${PATH}"

Test that the ``elp`` executable can be found indeed, and remove any previous server running (e.g. run ``killall elp``).



ELP From Binaries
_________________


`Prebuilt-binaries <https://github.com/WhatsApp/erlang-language-platform/releases>`_ are available.

One can download for example ``elp-linux-x86_64-unknown-linux-gnu-otp-28.tar.gz`` and, provided that the local glibc is not too ancient, a functional ``elp`` can be extracted from that archive, preferably in a dedicated ``~/Software/erlang-language-platform/target/release`` directory, for consistency.


Using ELP
.........

If using a separate ``build_info.json`` file that would be not be located in the root directory of the current application/project but in, for example, ``conf/build_info.json``, then the root directories of applications shall be defined in that file relatively to its location (hence, here, ``conf``), not relatively to its parent directory, where the ``.elp.toml`` referencing that file lies.

For example, if a ``bar`` project/application depends on a ``foo`` one whose parent directly (clone) is a sibling directory of this one, in ``bar/conf/build_info.json``, the ``foo`` application shall have a ``"dir": "../../foo"`` entry (as reached from ``bar/conf``), not a ``"dir": "../foo"`` one.

Then the ``src_dirs`` and ``extra_src_dirs`` entries for this project/application can be defined relatively to this ``dir`` directory [#]_.

.. [#] With Ceylan-Myriad, the ``list-src-dirs`` and ``list-extra-src-dirs`` make targets can be used in order to generate suitable values for these entries.


We also noticed that:

- albeit they *can* be resolved (for example they can be found by selecting ``Go to definition``), unfortunately the remote types (e.g. ``foo_mod:my_type()``) do not have their documentation displayed when hovering over them (unlike, surprisingly, functions, like ``foo_mod:my_function()``).
- one should avoid accessing one's clone through a symbolic link; more precisely, if a clone is named for example ``OSDL-Language`` and one wants it to be available also, in the same parent directory, as ``osdl_language``, a corresponding symlink may be created yet, due to either the Emacs LSP mode or ELP, operating from that directory will prevent ELP to locate the other applications (i.e. files loaded from there, for example with ``cd osdl_language; emacs src/foo.erl``, will not be able to resolve references pointing to the other applications in the ``build_info.json`` file)



Integrating ELP to Emacs
........................

For that `these guidelines <https://whatsapp.github.io/erlang-language-platform/docs/get-started/editors/emacs/>`_ shall be followed.

We simply recommend the use of the dedicated `Myriad configuration for Erlang <https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/conf/init-myriad-erlang-advanced.el>`_.



Installing rebar3
-----------------

One may use our `install-rebar3.sh <https://github.com/Olivier-Boudeville/Ceylan-Hull/blob/master/install-rebar3.sh>`_ script for that (installed from sources, or prebuilt).



.. _`using Emacs for Erlang`:

Using Emacs
-----------

Even when applying `only the minimal Erlang configuration <https://www.erlang.org/doc/apps/tools/erlang_mode_chapter.html#setup-on-unix>`_, a syntax-highlighting problem can often be noticed (at least with our code and Erlang 27.2 / Emacs 29.4), often starting after a docstring delimited with three double-quotes; then for example words in string literals are highlighted as if they were language keywords.

This can be fixed by selecting, in the ``Erlang`` (Emacs) menu, the ``Syntax Highlighting`` submenu, then any level (e.g. ``Level 4``, corresponding to ``erlang-font-lock-level-4``, which can be set with ``(setq font-lock-maximum-decoration 4)``).

in `init.el`, a specific key (here, F11) may be assigned for that::

 (global-set-key [f11] 'erlang-font-lock-level-4)

Problem: it would have to be entered again and again, even for a single buffer...

.. test with init.el-minimal-for-erlang-testing
.. for example look up, in oceanic.erl, '-spec execute_command'
.. Definition of Erlang support for Emacs in $ERL_INSTALL_ROOT/lib/erlang/emacs/erlang.el

See also `Using a LSP language server for Erlang`_.



.. _`using VS Code for Erlang`:

Using VS Code
-------------

It can be best `installed on Arch Linux <https://wiki.archlinux.org/title/Visual_Studio_Code>`_ with ``pacman -Sy code``, yet the `erlang-language-platform <https://marketplace.visualstudio.com/items?itemName=erlang-language-platform.erlang-language-platform>`_ does not look available in Open VSX; as a result, the ``visual-studio-code-bin`` proprietary Microsoft-branded release could be needed.

The user settings with the ``code`` package seem to be stored in ``~/.config/Code - OSS/User/settings.json``.

It can be run as ``/usr/bin/code``, which may be a symbolic link to ``/usr/bin/code-oss``.

The best VS Code extension for Erlang is most probably Pierrick Gourlain's `erlang <https://marketplace.visualstudio.com/items?itemName=pgourlain.erlang>`_ one.

To switch from (deprecated) ``erlang_ls`` to ``erlang-language-platform``, `apply these hints <https://zed.dev/docs/languages/erlang>`_.

In our experiment, most elements became unresolved in VS Code (probably due to some configuration of this tool, of the Erlang extension or of the ELP server), and we went back to Emacs.



Contributing to Erlang/OTP
--------------------------

A simple procedure may be:

- first, check, especially in the case of a bug fixing, whether it corresponds to an already `known issue <https://github.com/erlang/otp/issues>`_

- read at least the `Submitting Pull Requests <https://github.com/Olivier-Boudeville/erlang-otp/blob/master/CONTRIBUTING.md#submitting-pull-requests>`_ section of the official Erlang/OTP contribution guide; for documentation-related contributions, refer to `these guidelines <https://github.com/erlang/otp/wiki/Documentation>`_

- from one's GitHub account, fork the Erlang/OTP official repository, ``https://github.com/erlang/otp`` (just click on ``Fork``, at the top-right of this page), possibly as ``erlang-otp`` for clarity

- clone it; for example::

  $ cd ~/Software/Erlang
  $ git clone https://github.com/James-Bond/erlang-otp.git erlang-otp-github-my-fork
  $ cd erlang-otp-github-my-fork

- (configure your clone appropriately in order to authenticate easily)


- let's suppose the branch of the upcoming pull request is to derive from the ``maint`` one, and be named ``component/improve-something``::

  $ git remote add upstream https://github.com/erlang/otp.git
  $ git fetch upstream maint
  $ git checkout maint
  $ git checkout -b component/improve-something

- perform the changes, and commit them, with a message such as ``Fix some element of something`` (refer for that to the `Writing good commit messages <https://github.com/erlang/otp/wiki/Writing-good-commit-messages>`_ Erlang-official guidelines)

- push them: ``git push origin HEAD``

- create a corresponding pull request (PR) by visiting the link proposed by the remote, for example ``https://github.com/James-Bond/erlang-otp/pull/new/component/improve-something``

- in order to assess the corresponding authorisations of use/compliance, sign a suitable *Contributor License Agreement* (CLA), thanks to the `CLAassistant <https://github.com/cla-assistant/cla-assistant>`_ that automatically participates to the PR conversation

- wait for the automated tests (continuous integration) to pass and a reviewer to accept or deny this PR, or to request changes that one's does one's best to apply


Finally the PR is successfully merged, accepted and closed (see `this example <https://github.com/erlang/otp/pull/9425>`_) - and congratulations, you are an happy contributor to Erlang/OTP!


More in-depth readings on that topic:

- `Everything you need to know to start contributing to Erlang today! <https://medium.com/erlang-battleground/all-you-need-to-know-to-start-contributing-to-erlang-2fcd5748319e>`_, by Viacheslav Katsuba, especially to detail how changes should be performed and tested
- `Writing OTP Modules <https://docs.jj1bdx.tokyo/writing-otp-modules/html/>`_, by Kenji Rikitake


Uninstalling Erlang
-------------------

Typically useful to prevent version clashes / use of an unexpected version.

If Erlang was installed:

- thanks to a package manager, uninstall it the same way
- from sources, with a prefix (default one being ``PREFIX=/usr/local``), then execute, possibly as root:

.. code:: bash

  $ cd $PREFIX/bin && /bin/rm -f ct_run dialyzer epmd erl erlc escript run_erl to_erl typer
  $ cd $PREFIX/lib && /bin/rm -rf erlang




Micro-Cheat Sheet
=================

To avoid having to perform a lookup in the documentation:

- Erlang indices start at ``1`` (except the ones of the ``array`` module, the positions in binaries and ``string:slice/3``, which are zero-based)

- when they yield the same result, ``=:=`` is a bit more efficient than ``==``

- for tuples of unknown number of elements:

  - **setting** an element is to be done with ``setelement(positive_index(), tuple(), term()) -> tuple()``
  - **reading** an element is to be done with ``element(positive_index(), tuple()) -> term()``
  - **adding** an element at a given index (e.g. to append a record tag) is to be done with ``erlang:insert_element(positive_index(), tuple(), term()) -> tuple()``

  - **removing** an element at a given index (e.g. to chop a record tag) is to be done with ``erlang:delete_element(positive_index(), tuple()) -> tuple()``

(no need for the ``erlang`` module to be explicitly specified for the first two functions, as both are auto-imported)

- for (list, map, bit string) **comprehensions**, since Erlang 28.0, in addition to the usual, *relaxed* list generators (``Pattern <- ListExpr`` for lists and maps, ``BitstringPattern <= BitStringExpr`` for bit strings), `strict variants <https://www.erlang.org/doc/system/expressions.html#comprehensions>`_ thereof exist: ``Pattern <:- ListExpr`` for lists and maps, ``BitstringPattern <:= BitStringExpr`` for bit strings; these strict variants, instead of silently ignoring the generated elements that do not match the pattern, will raise an exception instead (e.g. ``exception error: no match of right hand side value XXX``)

- ``lists:foldl/3`` is generally the best folding procedure, and its `signature <https://www.erlang.org/doc/apps/stdlib/lists.html#foldl/3>`_ is ``foldl(Fun, Acc0, List) -> Acc1``

- for ``maps``: refer to `map expressions <https://www.erlang.org/doc/reference_manual/expressions.html#map_expressions>`_, the `maps module <https://www.erlang.org/doc/man/maps.html>`_ and the corresponding part of the `efficiency guide <https://www.erlang.org/doc/efficiency_guide/maps.html>`_; in short:

  - creating/updating maps is ``EmptyMap = #{}``, ``NewMFromScratch = #{K1 => V1, K2 => V2}`` or ``UpdatedM = M#{K1 => V1, K2 => V2}``
  - updating the value associated to an already-existing key ``K`` is ``ModM = M#{K := V}``
  - matching is ``#{K1 := V1, K2 := V2} = M`` where the ``K*`` are `guard expressions <https://www.erlang.org/doc/reference_manual/expressions.html#guard_expressions>`_ and the ``V*`` can be any pattern; matching an empty map is best done with ``when Map == #{}``

  - obtaining the value ``V`` associated to a key ``K`` that:

	- is expected to exist: ``V = maps:get(K, MyMap)`` (generally could/should be directly matched instead)
	- may or may not exist: ``case maps:find(K, MyMap) of {ok, V} -> ...; error -> ... end``

  - removing an entry: ``ShrunkMap = maps:remove(Key,Map)``

- to detect in a guard whether a term is a map, there is no ``is_map/1`` guard available: ``map_size/1`` will fail the guard if its argument is not a map; a map includes its size in the header word, so ``map_size/1`` is O(1); furthermore, the JIT will inline calls to ``map_size/1``

- a queue can be seen as being augmented (with ``queue:in/2``) on the right ("rear" of the queue), and shrunk (with ``queue:out/1``) on the left ("front" of the queue); for example, adding to an empty queue ``a`` then ``b``, results, when converting the resulting queue in a list, in ``[a,b]``; extracting an element of it returns ``a``, and the remaining queue corresponds then to ``[b]``

- a rule of thumb for naming in Erlang/OTP is that functions having ``size`` in their name are O(1), while functions having ``length`` in their name are O(N)

- when converting a float to a string, to set the precision (the number of digits after the decimal point) to ``P``, use: ``"~.Pf"``; for example, if ``P=5``, we have: ``"0.33333" = io_lib:format("~.5f", [1/3]).``

- the lesser-known ``--`` `list subtraction <https://www.erlang.org/doc/reference_manual/expressions.html#list-operationslist>`_ operator returns a list that is a copy of the first argument where, for each element in the second argument, the first occurrence of this element (if any) is removed
- refer to the `escape sequences <https://www.erlang.org/doc/reference_manual/data_types.html#escape-sequences>`_, typically in order to specify characters like "space" (``$\s``); ``$char`` is the notation to designate the ASCII value or Unicode code-point of the character ``char`` (e.g. ``$A``)

- the integer division operator is ``div``; for example: ``4 div 3 == 1``

- see the always handy `operator precedence <https://www.erlang.org/doc/reference_manual/expressions.html#operator-precedence>`_ and the various ways to `handle exceptions with try/catch <https://www.erlang.org/doc/reference_manual/expressions.html#try>`_; note that to catch *all* exceptions - i.e. those of the ``throw`` class, but also of the ``exit`` and ``error`` classes, one may use: ``try EXPR catch _:E -> ...`` (rather than just: ``try EXPR catch E -> ...``)

- in **guard expressions** (see `their list <https://www.erlang.org/doc/system/expressions.html#guard-expressions>`_):

  - because of side effects, no user-defined function is allowed in guards; refer to the two tables listing all the `BIFs supported in guards expressions <https://www.erlang.org/doc/reference_manual/expressions.html#guard-expressions>`_ (test or non-test BIFs); notably in a guard there is no way of testing whether a value belongs to a list (except, of course, if the list is statically defined, by testing explicitly each of its elements against said value, interspersed with ``orelse`` operators...)
  - a guard will fail if it returns false *or if it throws an exception*
  - to express an "and" operator, use a comma, i.e. "``,``", like in ``f(A, B, C, D) when A =:= B, C =/= A + D ->``
  - to express an "or" operator, use a semi-colon, i.e. "``;``"
  - ``andalso`` and ``orelse`` behave *there* as tests; they mostly convey the same meaning as "``,``" and "``;``" respectively, except that they shortcut (they do not evaluate their second operand if the first one suffices), that they do not catch exceptions as they happen (i.e. if a first guard throws, any next guards will not be evaluated, and the whole guard sequence will fail) and that their code is a little less effective - but they can be nested inside guards (refer to `this section <https://learnyousomeerlang.com/syntax-in-functions#guards-guards>`_ for more details)

- to handle **binaries**:

  - a binary is a bit string whose number of bits is a multiple of 8 (it can be represented as whole bytes)
  - one may refer to `this cheat sheet <https://cheatography.com/fylke/cheat-sheets/erlang-binaries/>`_; see also an `introduction to the bit syntax <https://www.erlang.org/doc/programming_examples/bit_syntax.html>`_ (including `bit string comprehensions <https://www.erlang.org/doc/reference_manual/expressions.html#bit-string-comprehensions>`_) and its `full reference <https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax>`_, the `Constructing and Matching Binaries <https://www.erlang.org/doc/efficiency_guide/binaryhandling.html>`_ section and the `binary <https://www.erlang.org/doc/man/binary.html>`_ module; see also our `bin_utils <https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/src/data-management/bin_utils.erl>`_ module
  - as a rule of thumb:

	- even if it may seem a bit counter-intuitive, *integers* (which is the default matching type) are handled at the **bit** level (e.g. ``A:16`` means an integer on two bytes), whereas *binaries* are handled at the **byte** level (e.g. ``B:16/binary`` means (a binary of) 16 **bytes**) - indeed their bit-level counterparts are *bitstrings*
	- to match any tail (remaining part) of a binary, the corresponding mute variable must be suffixed with ``/binary`` (e.g. with ``<<FullData:FullLen/binary, _NextChunk/binary>>``), otherwise (e.g. with just ``<<FullData:FullLen/binary, _NextChunk>>``), the ``_NextChunk`` mute variable will attempt to match only a (single) one-byte integer
	- unlike lists, binaries are preferably built by appending `on their right <https://www.erlang.org/doc/efficiency_guide/binaryhandling.html#constructing-binaries>`_

  - to determine the size (memory footprint) of a binary, use: ``1 = size(<<122>>)``; for a bitstring: ``8 = bit_size(<<122>>)``

- typically for non-critical code (e.g. tests or temporary, debugging code):

  - to avoid repeating a prefixing module, `imports can be done <https://www.erlang.org/doc/reference_manual/modules#pre-defined-module-attributes>`_, like in: ``-import(lists, [map/2, foldl/3, foldr/3]).``
  - to suppress warnings/errors whenever elements are not used, specify for:

	- variables: ``-compile(nowarn_unused_vars).``
	- functions (rather than silencing them with an ``-export([f/1, g/3])``): ``-compile([ {nowarn_unused_function, [{f,1}, {g,3}]} ]).``
	- types: they can be silenced with an ``-export_type([t1/0, t2/1])``), which is better (more selective) than ``-compile(nowarn_unused_type)`` (unfortunately ``-compile([ {nowarn_unused_type, [t1/0, t2/1]} ]).`` is not supported)

- to define anonymous (i.e. lambda) functions:

  - beware to the `shadowing of variable bindings <https://www.erlang.org/doc/system/funs.html#variable-bindings-within-a-fun>`_ in their function head; using extra guards might be needed
  - an example of spec involving them: ``-spec foo(integer(), fun((key()) -> value())) -> integer()`` (note the two levels of parentheses after ``fun``)
  - for a multi-clause lambda function, for example for a fold, just use the ``fun`` name for the first clause, and omit it for the next ones:

.. code:: erlang

   F = fun( K, [ _SingleV ], RetMap ) ->
			  RetMap;
		  ( K, Dups, RetMap ) ->
			  table:add_entry( K, Dups, RetMap )
	   end,


- in boolean expressions **outside of guards**:

  - do not use ``and`` and ``or``, which are strict boolean operators, not intended for control; indeed their precedence is low (parentheses around the conditions being then necessary, like in ``(A =:= B) and (C =/= D)``) and, more importantly, they do not short-circuit, i.e. in ``E = A and B``, B will be evaluated even if A is already known as false (so is E), and in ``E = A or B``, B will be evaluated even if A is already known as true (so is E)

  - prefer ``andalso`` and ``orelse``, which are *control* operators; they short-circuit, and their precedence is `low enough <https://www.erlang.org/doc/reference_manual/expressions.html#operator-precedence>`_ to spare the need of extra parentheses [#]_
  - so ``case (A =:= B) and (C =/= D) of`` shall become ``case A =:= B andalso C =/= D of``
  - a common pattern is to use ``andalso`` in order *to evaluate a target expression iff a boolean expression is true*, to replace a longer expression like:

.. code:: erlang

  case BOOLEAN_EXPR of

	  true ->
		  DO_SOMETHING;

	  false ->
		  ok

  end

.. [#] Note that it is *not* the case of the ``and`` and ``or`` operators, whose precedence is higher than, notably, the comparison operators.

	   For example a clause defined as ``f(I) when is_integer(I) and I >= 0 -> ...``  will never be triggered as it is interpreted as ``f(I) when (is_integer(I) and I) >= 0 -> ...``, and the ``and`` guard will always fail as I is an integer here, not a boolean. So such a clause should be defined as the (correct) ``f(I) when is_integer(I) andalso I >= 0 -> ...`` instead.


with the equivalent (provided ``BOOLEAN_EXPR`` evaluates to either ``true`` or ``false`` - otherwise a ``bad argument`` exception will be thrown) yet shorter: ``BOOLEAN_EXPR andalso DO_SOMETHING``; for example: ``[...], OSName =:= linux andalso fix_for_linux(), [...]``

Similarly, ``orelse`` can be used *to evaluate a target expression iff a boolean expression is false*, to replace a longer expression like:

.. code:: erlang

  case BOOLEAN_EXPR of

	  true ->
		  ok;

	  false ->
		  DO_SOMETHING;

  end

with: ``BOOLEAN_EXPR orelse DO_SOMETHING``; for example: ``[...], file_utils:exists("/etc/passwd") orelse throw(no_password_file), [...]``

In both ``andalso / orelse`` cases, the ``DO_SOMETHING`` branch may be a single expression, or a sequence thereof (i.e. a body), in which case a ``begin/end`` block may be of use, like in:

.. code:: erlang

  file_utils:exists("/etc/passwd") orelse
	begin
		trace_utils:notice("No /etc/password found."),
		throw(no_password_file)
	end


Similarly, taking into account the aforementioned precedences, ``Count =:= ExpectedCount orelse throw({invalid_count, Count})`` will perform the expected check.

Be wary of not having `precedences wrong <https://www.erlang.org/doc/reference_manual/expressions.html#operator-precedence>`_, lest bugs are introduced like the one in:

.. code:: erlang

 MaybeListenerPid =:= undefined orelse
	MaybeListenerPid ! {onDeserialisation, [self(), FinalUserData]}

(``orelse`` having more priority than ``!``, parentheses shall be added, otherwise, if having a PID, the message will actually be sent to any process that would be registered as ``true``)


For the record, an alternative is ``[f(...) || BoolCondition]``, like in: ``_ = [put('$ancestors', Ancestors) || Shell =/= {}]`` (in ``group.erl``).

Some of these elements have been adapted from the `Wings3D coding guidelines <https://github.com/dgud/wings/blob/master/CodingGuidelines>`_.



Erlang Resources
================

- the reference is the `Erlang official website <http://erlang.org>`_

- for teaching purpose, we would dearly recommend `Learn You Some Erlang for Great Good! <https://learnyousomeerlang.com/content>`_; many other high-quality `Erlang books <https://erlangforums.com/c/erlang-learning-resources/8>`_ exist as well; one may also check the `Erlang track <https://exercism.org/tracks/erlang>`_ on Exercism

- in addition to the module index mentioned in the `Erlang Installation`_ section, using the `online search <https://erlang.org/doc/search/>`_ and/or `Erldocs <https://erldocs.com/>`_ may also be convenient

- the Erlang `community <https://www.erlang.org/community>`_ is known to be pleasant and welcoming to newcomers; one may visit the `Erlang forums <https://erlangforums.com/>`_, which complement the `erlang-questions <https://erlang.org/pipermail/erlang-questions/>`_ mailing list (use `this mirror <https://groups.google.com/g/erlang-programming>`_ in order to search through the past messages of this list)

- for those who are interested in parse transforms (the Erlang way of doing metaprogramming), the `section about The Abstract Format <https://www.erlang.org/doc/apps/erts/absform.html>`_ is essential (despite not being well known)

- to better understand the inner workings of the VM: `The Erlang Runtime System <https://blog.stenmans.org/theBeamBook/>`_, a.k.a. "the BEAM book", by Erik Stenman

- `BEAM Wisdoms <http://beam-wisdoms.clau.se/en/latest>`_, by Dmytro Lytovchenko


:raw-html:`<a name="howtos_bottom"></a>`
