.. _Top:


.. title:: Ceylan-HOWTOs: About Erlang

------
Erlang
------


.. role:: raw-html(raw)
   :format: html

.. role:: raw-latex(raw)
   :format: latex


:raw-html:`<a name="howtos_top"></a>`

:raw-html:`<div class="banner"><p><em>Ceylan HOWTOs</em> <a href="http://howtos.esperide.org">browse latest</a> <a href="Ceylan-HOWTOs-english.pdf">get PDF</a> <a href="#howtos_top">go to top</a> <a href="#howtos_toc">go to toc</a> <a href="#howtos_bottom">go to bottom</a> <a href="Ceylan-HOWTOs-overview-english.html">go to HOWTOs</a> <a href="mailto:about(dash)ceylan-howtos(at)esperide(dot)com?subject=[Ceylan-HOWTOs]%20Remark%20about%20Erlang">email us</a></p></div>`


:raw-html:`<center><img src="howtos-title.png" id="responsive-image-ultrasmall"></img>`


:Organisation: Copyright (C) 2021-GENERATION_YEAR_TAG Olivier Boudeville
:Contact: about (dash) howtos (at) esperide (dot) com
:Creation date: Saturday, November 20, 2021
:Lastly updated: GENERATION_DATE_TAG


:raw-html:`<a name="howtos_toc"></a>`

.. _`table of contents`:


.. contents:: **Table of Contents**
  :local:
  :depth: 2


:raw-html:`</center>`



Overview
========

`Erlang <https://en.wikipedia.org/wiki/Erlang_(programming_language)>`_  is a concurrent, functional programming language available as free software; see `its official website <https://www.erlang.org/>`_ for more details.

Erlang is dynamically typed, and is executed by the `BEAM virtual machine <https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)>`_. This VM (*Virtual Machine*) operates on bytecodes and can perform Just-In-Time compilation. It powers also `other related languages <https://github.com/llaisdy/beam_languages>`_, such as Elixir and LFE.



Let's Start with some Shameless Advertisement for Erlang and the BEAM VM
========================================================================

Taken from `this presentation <https://erlangforums.com/t/erlang-101-processes-parallelization/594>`_:

.. Hint::
 What makes Elixir StackOverflow’s #4 most-loved language?

 What makes Erlang and Elixir StackOverflow’s #3 and #4 best-paid languages?

 How did WhatsApp scale to billions of users with just dozens of Erlang engineers?

 What’s so special about Erlang that it powers CouchDB and RabbitMQ?

 Why are multi-billion-dollar corporations like Bet365 and Klarna built on Erlang?

 Why do PepsiCo, Cars.com, Change.org, Boston’s MBTA, and Discord all rely on Elixir?

 Why was Elixir chosen to power a bank?

 Why does Cisco ship 2 million Erlang devices each year? Why is Erlang used to control 90% of Internet traffic?



.. _`Erlang Installation`:


Installation
============

Erlang can be installed thanks to the various options listed in `these guidelines <https://www.erlang.org/downloads>`_.

Building Erlang from the sources of its latest stable version is certainly the best approach; for more control we prefer relying on our `custom procedure <https://myriad.esperide.org/#software-prerequisites>`_.

For a development activity, we recommend also specifying the following options to our ``conf/install-erlang.sh`` script:

- ``--doc-install``, so that the reference documentation can be accessed locally (in ``~/Software/Erlang/Erlang-current-documentation/``); creating a bookmark pointing to the module index, located in ``doc/man_index.html``, would most probably be useful

- ``--generate-plt`` in order to generate a PLT file allowing the static type checking that applies to this installation (may be a bit long and processing-intensive, yet it is to be done once per built Erlang version)

Run ``./install-erlang.sh --help`` for more information.

Once installed, ensure that ``~/Software/Erlang/Erlang-current-install/bin/`` is in your PATH (ex: by enriching your ``~/.bashrc`` accordingly), so that you can run ``erl`` (the Erlang interpreter) from any location, resulting a prompt like:

.. code:: bash

 $ erl
 Erlang/OTP 24 [erts-12.1.5] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:1] [jit]

 Eshell V12.1.5  (abort with ^G)
 1>

Then enter ``CTRL-C`` twice in order to come back to the (UNIX) shell.

Congratulations, you have a functional Erlang now!



Ceylan's Language Use
=====================

Ceylan users shall note that most of our related developments (namely `Myriad <http://myriad.esperide.org>`_, `WOOPER <http://wooper.esperide.org>`_, `Traces <http://traces.esperide.org>`_, `LEEC <http://leec.esperide.org>`_, `Seaplus <http://seaplus.esperide.org>`_, `Mobile <http://mobile.esperide.org>`_, `US-Common <http://us-common.esperide.org>`_, `US-Web <http://us-web.esperide.org>`_ and `US-Main <http://us-main.esperide.org>`_) depart significantly from the general conventions observed by most Erlang applications:

- notably because of their reliance on parse transforms, by default they rely on our own build system based on `GNU make <Build.html#gnu-make>`_ (rather than on `rebar3 <https://www.rebar3.org/>`_)
- they tend not to rely on OTP abstractions such as ``gen_server``, as WOOPER offers OOP (*Object-Oriented Programming*) ones that we prefer



Using the Shell
===============

If it is as simple to run ``erl``, we prefer, with Ceylan settings, running ``make shell`` in order to benefit from a well-initialized VM (notably with the full code path of the current layer and the ones below).

Refer then to the `shell commands <https://www.erlang.org/doc/man/shell.html#shell-commands>`_, notably for:

- ``f/1``, used as ``f(X).`` in order to *forget* a variable ``X``, i.e. to remove the binding of this variable and be able to (re)assign it afterwards
- ``rr/{1,2,3}`` (ex: used as ``rr(Path).``) to *read records* and have them available on the shell; for example, to be able to use the records defined by xmerl:

.. code:: erlang

 1> rr(code:lib_dir(xmerl) ++ "/include/xmerl.hrl").


See also the `JCL mode <https://www.erlang.org/doc/man/shell.html#jcl-mode>`_ (for *Job Control Language*) to connect and interact with other Erlang nodes.



Language Implementation
=======================


Message-Passing: Copying vs Sharing
-----------------------------------

Knowing that, in functional languages such as Erlang, terms ("variables") are immutable, why could not they be shared between local processes when sent through messages, instead of being copied in the heap of each of them, as it is actually the case with the Erlang VM?

The reason lies in the fact that, beyond the constness of these terms, their life-cycle has also to be managed. If they are copied, each process can very easily perform its (concurrent, autonomous) garbage collections. On the contrary, if terms were shared, then reference counting would be needed to deallocate them properly (neither too soon nor never at all), which, in a concurrent context, is bound to require locks.

So a trade-off between memory (due to data duplication) and processing (due to lock contention) has to be found and at least for most terms (excepted larger binaries), the sweet spot consists in sacrificing a bit of memory in favour of a lesser CPU load. Solutions like `persistent_term <https://www.erlang.org/doc/man/persistent_term.html>`_ may address situations where more specific needs arise.


.. _JIT:

Just-in-Time Compilation
------------------------

This long-awaited feature, named *BeamAsm* and whose rationale and history have been detailed in `these articles <https://www.erlang.org/blog/the-road-to-the-jit/>`_, has been introduced in Erlang 24 and shall transparently lead to increased performances for most applications.




Static Typing
-------------

Static type checking can be performed on Erlang code; the usual course of action is to use `Dialyzer <https://www.erlang.org/doc/man/dialyzer.html>`_ - albeit other solutions like `Gradualizer <https://github.com/josefs/Gradualizer>`_ exist.

A few `statically-typed languages <https://github.com/llaisdy/beam_languages#statically-typed-languages>`_ can operate on top of the Erlang VM, even if none has reached yet the popularity of Erlang or Elixir (that are dynamically-typed).

In addition to the increased type safety that statically-typed languages permit (possibly applying to sequential code but also to inter-process messages), it is unsure whether such extra static awareness may also lead to better performances (especially now that the standard compiler supports JIT_).



Intermediate Languages
----------------------

To better discover the inner workings of the Erlang compilation, one may look at the `eplaypen online demo <http://tryerl.seriyps.ru/>`_ (whose project is `here <https://github.com/seriyps/eplaypen>`_) and/or at the `Compiler Explorer <https://godbolt.org/>`_ (which supports the Erlang language among others).

Both of them allow to read the intermediate representations involved when compiling Erlang code (BEAM stage, erl_scan, preprocessed sources, abstract code, Core Erlang, Static Single Assignment form, BEAM VM assembler opcodes, x86-64 assembler generated by the JIT, etc.).


About Security
==============

- one should not encrypt messages directly with a key pair (ex: with RSA, only messages up to around 200 bytes long can be encrypted):  one should encrypt only a *symmetric key* (generated by a cryptographically-safe random algorithm) that is then used to encrypt one's message(s); ensure an Encrypt-Then-Authenticate scheme to prevent padding oracle attacks (and a secure-compare algorithm for the *Message Authentication Code* verification to prevent timing attacks); using `libsodium <https://doc.libsodium.org/>`_ should make mistakes using the standard crypto primitives less error-prone; see the `enacl <https://github.com/jlouis/enacl>`_ Erlang binding for that; for more information, refer to `the corresponding thread <https://erlangforums.com/t/cannot-encrypt-a-long-binary-using-public-key-encrypt-private-2/724>`_

- relevant sources of information:

  - books:

	- ``Cryptography Engineering: Design Principles and Practical Applications``
	- ``Practical Cryptography``

  - the `Security Working Group <https://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/>`_ of the EEF (*Erlang Ecosystem Foundation*)



Erlang Resources
================

- the reference is the `Erlang official website <http://erlang.org>`_

- for teaching purpose, we would dearly recommend `Learn You Some Erlang for Great Good! <https://learnyousomeerlang.com/content>`_; many other high-quality `Erlang books <https://erlangforums.com/c/erlang-learning-resources/8>`_ exist as well; one may also check the `Erlang track <https://exercism.org/tracks/erlang>`_ on Exercism

- in addition to the module index mentioned in the `Erlang Installation`_ section, using the `online search <https://erlang.org/doc/search/>`_ and/or `Erldocs <https://erldocs.com/>`_ may also be convenient

- the Erlang `community <https://www.erlang.org/community>`_ is known to be pleasant and welcoming to newcomers; one may visit the `Erlang forums <https://erlangforums.com/>`_, which complement the `erlang-questions <https://erlang.org/pipermail/erlang-questions/>`_ mailing list

- for those who are interested in parse transforms (the Erlang way of doing metaprogramming), the `section about The Abstract Format <https://www.erlang.org/doc/apps/erts/absform.html>`_ is esential (despite not being well known)

- to better understand the inner working of the VM: `The Erlang Runtime System <https://blog.stenmans.org/theBeamBook/>`_, a.k.a. "the BEAM book", by Erik Stenman



